{"./":{"url":"./","title":"Introduction","keywords":"","body":"1. Introduction1. Introduction 这是我的《Go语言精进之路》的读书笔记的gitbook，会时不时更新。 By YangXin Xu            updated 2023-10-03 15:33:39 "},"第1条-了解Go语言的诞生和演进.html":{"url":"第1条-了解Go语言的诞生和演进.html","title":"第1条-了解Go语言的诞生和演进","keywords":"","body":"1. Go语言的诞生2. Go语言的早期团队和演进历程3. Go语言正式发布并开源1. Go语言的诞生 2009年9月20日，以下三位谷歌的大佬进行了一次有关设计一门新编程语言的讨论 Rob Pike：贝尔实验室早期成员，参与了Plan 9操作系统、C编译器和多种语言编译器的设计和实现，UTF-8的发明者之一 Robert Griesemer：Java的HotSpot虚拟机和Chrome浏览器的JavaScript V8引擎的设计者之一 Ken Thompson：图灵机得主，Unix之父，C语言的发明者之一 随后经过几次讨论和会议，Robert Griesemer 发出了一封题为 “prg lang discussion” 的电邮，对讨论进行了归纳总结：在C语言的基础上，修正明显的缺陷、删除被诟病的特性、增加缺失的功能： 使用 import 替代 include 去除宏 用一个源文件替代.h和.c文件，自动提取模块接口 语句像C语言一样，但需修正switch语句 表达式像C语言一样，但有些注意事项 基本上是强类型的，但需支持运行时类型 数组应该有边界检查 具备GC机制 支持接口 支持嵌套和匿名函数/闭包 一个简单的编译器 各种语言机制应该能产生可预测代码 golang仅应用于命名G语言官方网站，因为当时go.com域名被迪士尼公司占用 2. Go语言的早期团队和演进历程 2008年年初，Ken Thompson 实现了第一版Go编译器。此编译器先将Go代码转换为C代码，再由C编译器编译成二进制文件 2008年年中，同样在谷歌工作的 Ian Lance Taylor 为Go语言实现了一个GCC的前端，成为了Go语言的第二个编译器。随后他以第四位成员的身份正式加入Go语言开发团队 Russ Cox 是第五位加入Go语言开发团队的成员。他利用函数类型也可以拥有自己的方法这个特性巧妙设计出了http包的HandlerFunc类型 3. Go语言正式发布并开源 2009年10月30日，Rob Pike 在 Google Techtalk 上做了一次有关Go语言的演讲——The Go Programming Language ，首次将Go语言公之于众 2009年11月10日，G语言项目正式开源，开源后的Go语言吸引力全世界开发者的目光，越来越多贡献者开始为Go语言添砖加瓦 Go语言开源后，许多云计算领域的大厂和初创公司成为Go语言的早期接纳者，并产生了一系列杀手级项目：容器引擎Docker、云原生实施标准平台Kubernetes、服务网格Istio、区块链公链以太坊(Ethereum)、联盟链超级账本(Hyperledger Fabric)、分布式关系型数据库TiDB和CockroachDB、云原生监控系统Prometheus等 By YangXin Xu            updated 2023-10-03 13:00:54 "},"第2条-选择适当的Go语言版本.html":{"url":"第2条-选择适当的Go语言版本.html","title":"第2条-选择适当的Go语言版本","keywords":"","body":"1. Go语言的先祖2. Go语言的版本发布历史3. Go语言的版本选择建议1. Go语言的先祖 Go继承了诸多编程语言的特性： Go的基本语法参考了C语言，是”C家族语言“的一个分支 Go的声明语法、包概念则受到了Pascal、Modula、Oberon的启发 ⼀ 些并发的思想则来自受到Tony Hoare教授CSP理论影响的编程语言 2. Go语言的版本发布历史 (略) 3. Go语言的版本选择建议 Go开发团队一直建议大家使用最新的发布版 而开源社区则倾向于使用最新版本之前的哪个版本 By YangXin Xu            updated 2023-10-03 13:11:22 "},"第3条-理解Go语言的设计哲学.html":{"url":"第3条-理解Go语言的设计哲学.html","title":"第3条-理解Go语言的设计哲学","keywords":"","body":"1. 追求简单，少即是多2. 偏好组合，正交解耦3. 原生并发，轻量高效4. 面向工程，“自带电池”4.1. 语言4.2. 标准库4.3. 工具链1. 追求简单，少即是多 简单是一种伟大的美德，但我们需要更艰苦地努力才能实现它，并需要经过一个教育的过程才能去欣赏和领会它。但糟糕的是：复杂的东西似乎更有市场。 ——Edsger Dijkstra，图灵奖得主 Go 语言实际上是很复杂的，但只是让大家感觉很简单 ——Rob Pike，Go 语言之父 Go 的设计者们在语言设计之初就 拒绝走语言特性融合的道路，而选择了“做减法”，选择了“简单”，他们把复杂性留给了语言自身的设计和实现（Go 核心开发组自己），而将简单、易用和清晰留给了广大 Gopher： 简洁、常规的语法（不需要解析符号表），它仅有 25 个关键字； 内置垃圾收集，降低开发人员内存管理的心智负担； 没有头文件； 显式依赖（package）； 没有循环依赖（package）； 常量只是数字； 首字母大小写决定可见性； 任何类型都可以拥有方法（没有类）； 没有子类型继承（没有子类）； 没有算术转换； 接口是隐式的（无须 implements 声明）； 方法就是函数； 接口只是方法集合（没有数据）； 方法仅按名称匹配（不是按类型）； 没有构造函数或析构函数； n++和 n--是语句，而不是表达式； 没有++n 和--n； 赋值不是表达式； 在赋值和函数调用中定义的求值顺序（无“序列点”概念）； 没有指针算术； 内存总是初始化为零值； 没有类型注解语法（如 C++中的 const、static 等）； 没有模板/泛型； 没有异常（exception）； 内置字符串、切片（slice）、map 类型； 内置数组边界检查； 内置并发支持； Go 设计者推崇 “最小方式”思维 ：即一件事情仅有一种方式或数量尽可能少的方式去完成，这大大减少了开发人员在选择路径方式及理解他人所选路径方式上的心智负担 在 Go 演化进入关键阶段（走向 Go 2）的今天，有人向 Go 开发团队提出过这样一个问题：Go 后续演化的最大难点是什么？Go 开发团队的一名核心成员回答道：“最大的难点是如何继续保持 Go 语言的简单。” 2. 偏好组合，正交解耦 当我们有必要采用另一种方式处理数据时，我们应该有一些耦合程序的方式，就像花园⾥将浇⽔的软管通过预置的螺丝扣拧入另一段那样，这也是 Unix IO 采用的方式。 ——Douglas McIlroy，Unix 管道的发明者（1964） Go 语言本质上不属于经典 OO 语言范畴。Go 语言遵从的设计哲学是组合，通过组合将程序各个部分有机耦合在一起 在语言设计层面，Go 提供了正交的语法元素供后续组合使用，包括： Go 语言无类型体系（type hierarchy），类型之间是独⽴的，没有子类型的概念； 每个类型都可以有自己的方法集合，类型定义与方法实现是正交独立的； 接口（interface）与其实现之间隐式关联； 包（package）之间是相对独立的，没有子包的概念； Go 语言为我们呈现了这样一幅图景：一座座没有关联的“孤岛”，但每个岛内又都很精彩。现在摆在面前的工作就是以最适当的方式在这些孤岛之间建立关联（耦合），形成一个整体。Go采用了组合的方式，也是唯一的方式 Go 语言提供的最为直观的组合的语法元素是 类型嵌入（type embedding） 。通过类型嵌入，我们可以将已经实现的功能嵌入新类型中，以快速满足新类型的功能需求。我们也可以称之为 垂直组合 interface 是 Go 语言中真正的“魔法”，是 Go 语言的一个创新设计， 它只是方法集合，且与实现者之间的关系是隐式的，它让程序各个部 分之间的耦合降至最低，同时是连接程序各个部分的“纽带”。隐式的 interface 实现会不经意间自然而然地满足依赖抽象、里氏替换、接口隔离等设计原则。我们也可称之为 水平组合 综上： 组合原则的应用塑造了 Go 程序的骨架结构； 类型嵌入为类型提供垂直扩展能力； interface 是水平组合的关键，它好比程序肌体上 的“关节”，给予连接“关节”的两个部分各自“自由活动”的能力，而整体上又实现了某种功能； 3. 原生并发，轻量高效 并发是有关结构的，而并行是有关执行的。 ——Rob Pike（2012） Go 的设计者敏锐地把握了 CPU 向多核方向发展的这一趋势，在决定不再使用 C++而去创建一门新语言的时候，果断将 面向多核、原生内置并发支持 作为新语言的设计原则之一 Go 语言原生支持并发的设计哲学体现在以下几点： Go 语言采用 轻量级协程并发模型，使得 Go 应用在面向多核硬件时更具可扩展性 Go 放弃了传统的基于操作系统线程的并发模型，而采用了 用户层轻量级线程（Go 称其为 goroutine） Go 运行时默认每个 goroutine 分配的栈空间仅为 2KB。goroutine 调度的切换也不用陷入操作系统内核层完成，代价很低。因此，在一个 Go 程序中可以创建成千上万个并发的 goroutine。 goroutine 的调度全靠 Go 自己完成，实现 Go 程序内 goroutine 之间公平地竞争 CPU 资源的任务就落到了 Go 运行时头上。而将这些 goroutine 按照一定算法放到 CPU 上执行的程序就称为 goroutine调度器 Go 语言为开发者提供的支持并发的语法元素和机制： 执行单元：goroutine； 创建和销毁方式：go+函数调用；函数退出即 goroutine 退出； 并发 goroutine 的通信：通过语言内置的 channel 传递消息或实现同步，并通过 select 实现多路 channel 的并发控制； 并发原则对 Go 开发者在程序结构设计层面的影响 并发是有关结构的，它是一种将一个程序分解成多个小片段并且 每个小片段都可以独立执⾏的程序设计方法；并发程序的小片段之间一般存在通信联系并且通过通信相互协作； 并行是有关执行的，它表示同时进行一些计算任务； 并发程序的结构设计不要局限于在单核情况下处理能力的高低，而要以 在多核情况下充分提升多核利用率、获得性能的自然提升为最终目的 4. 面向工程，“自带电池” 软件工程指引着 Go 语言的设计。 ——Rob Pike（2012） 三位 Go 语言之父在设计 Go 语言时的初衷：面向真实世界中 Google 内部大规模软件开发存在的各种问题，为这些问题提供答案 在 Go 语言最初设计阶段就将 解决工程问题 作为 Go 的设计原则之一去考虑 Go 语法、工具链与标准库的设计，这也是 Go 与那些偏学院派、偏研 究性编程语言在设计思路上的一个重大差异 Go 设计者将所有工程问题浓缩为一个词：scale 。Go 的设计目标就是帮助开发者更容易、更高效地管理两类规模： 生产规模：用 Go 构建的软件系统的并发规模，比如这类系统并发关注点的数量、处理数据的量级、同时并发与之交互的服务的数 量等； 开发规模：包括开发团队的代码库的大小，参与开发、相互协作的工程师的人数等； 4.1. 语言 面向工程的语言设计细节要考量以下这些： 重新设计编译单元和目标文件格式，实现 Go 源码快速构建，将大工程的构建时间缩短到接近于动态语言的交互式解释的编译时间。 如果源文件导入了它不使用的包，则程序将无法编译。这既可以充分保证 Go 程序的依赖树是精确的，也可以保证在构建程序时不会编译额外的代码，从而最大限度地缩短编译时间。 去除包的循环依赖。循环依赖会在大规模的代码中引发问题，因为它们要求编译器同时处理更大的源文件集，这会减慢增量构建速度。 在处理依赖关系时，有时会通过允许一部分重复代码来避免引入较多依赖关系。比如：net 包具有其自己的整数到十进制转换实现，以避免依赖于较大且依赖性较强的格式化 io 包。 包路径是唯一的，而包名不必是唯一的。导入路径必须唯一标识要导入的包，而名称只是包的使用者对如何引用其内容的约定。包名不必是唯一的约定大大降低了开发人员给包起唯一名字的心 智负担。 故意不支持默认函数参数。因为在规模工程中，很多开发者利用默认函数参数机制向函数添加过多的参数以弥补函数 API 的设计缺陷，这会导致函数拥有太多的参数，降低清晰度和可读性。 首字母大小写定义标识符可见性，这是 Go 的一个创新。它让开发人员通过名称即可知晓其可见性，而无须回到标识符定义的位置查找并确定其可见性，这提升了开发人员阅读代码的效率。 在语义层面，相对于 C，Go 做了很多改动，提升了语言的健壮性，比如去除指针算术，去除隐式类型转换等。 内置垃圾收集。这对于大型工程项目来说，大大降低了程序员在 内存管理方面的负担，程序员使用 GC 感受到的好处超过了付出的成本，并且这些成本主要由语言实现者来承担。 内置并发⽀持，为网络软件带来了简单性，而简单又带来了健壮，这是大型工程软件开发所需要的。 增加类型别名，支持大规模代码库的重构。 4.2. 标准库 Go 被称为 “自带电池”（battery-included） 的编程语言 如果说⼀门编程语言“自带电池”，则说明这门语言标准库功能丰富，多数功能无须依赖第三方包或库，Go 语言恰是这类编程语言 4.3. 工具链 Go 语言提供了十分全面、贴心的编程语言官方工具链，涵盖了编译、编辑、依赖获取、 调试、测试、⽂档、性能剖析等的方方面面： 构建和运行：go build/go run 依赖包查看与获取：go list/go get/go mod xx 编辑辅助格式化：go fmt/gofmt 文档查看：go doc/godoc 单元测试/基准测试/测试覆盖率：go test 代码静态分析：go vet 性能剖析与跟踪结果查看：go tool pprof/go tool trace 升级到新 Go 版本 API 的辅助工具：go tool fix 报告 Go 语言 bug：go bug Go 构建了⼀个开放的工具链生态系统，它鼓励社区和开发人员为 Go 添加更多、更实用的工具，而更多、更实用的工具反过来又帮助 Go 更好地解决工程上的“规模化”问题，这是一个良性的生态循环。 By YangXin Xu            updated 2023-10-03 21:30:38 "},"第4条-使用Go语言原生编程思维来写Go代码.html":{"url":"第4条-使用Go语言原生编程思维来写Go代码.html","title":"第4条-使用Go语言原生编程思维来写Go代码","keywords":"","body":"1. 语言与思维2. 现实的投影2.1. C 语言版本2.2. Haskell 版本2.3. Go 语言版本3. Go 语言原生编程思维1. 语言与思维 在人类自然语言学界有⼀个很著名的假说——“萨丕尔-沃夫假说”，这个假说的内容是这样的：“语言影响或决定人类的思维方式。” 2. 现实的投影 埃拉托斯特尼素数筛算法的不同语言实现 2.1. C 语言版本 #include #define LIMIT 50 #define PRIMES 10 void sieve() { int c, i,j,numbers[LIMIT], primes[PRIMES]; for (i=0;i C 版本的素数筛程序是⼀个常规实现。它定义了两个数组 numbers 和 primes，“筛”的过程在 numbers 这个数组中进行（基于纯内存修改），非素数的数组元素被设置为-1，便于后续提取。 2.2. Haskell 版本 sieve [] = [] sieve (x:xs) = x : sieve (filter (\\a -> not $ a `mod` x == 0) xs) n = 100 main = print $ sieve [2..n] Haskell 版本采用了函数递归的思路，通过“filter 操作集合”，用谓词（过滤条件）\\a -> not $ a `mod` x == 0 筛除素数的倍数，将未筛除的数的集合作为参数传递归递给下去。 2.3. Go 语言版本 func Generate(ch chan Go 版本程序实现了⼀个并发素数筛，它采用的是 goroutine 的并发组合。程序从素数 2 开始，依次为每个素数建⽴⼀个 goroutine，用 于作为筛除该素数的倍数。 3. Go 语言原生编程思维 编程语言影响编程思维，每种编程语言都有属于自己的原生编程思维： C 语言相信程序员，提供指针和指针运算，让 C 程序员天马行空地自由发挥，接近提出的直接内存操作让 C 程序拥有很高的性能 C++支持多范式（命令式、OO、泛型），推荐使用最新代表现代语言发展特色的泛型等高级范式 Python 语言更是形成了 Pythonic 规则来指导 Python 程序员写出符合 Python 思维或惯用法的代码 By YangXin Xu            updated 2023-10-03 21:29:25 "},"第5条-使用得到工人且广泛使用的项目结构.html":{"url":"第5条-使用得到工人且广泛使用的项目结构.html","title":"第5条-使用得到工人且广泛使用的项目结构","keywords":"","body":"1. Go 项目的项目结构2. Go 语言典型项目结构2.1. Go 项目结构的最小标准布局2.2. 以构建二进制可执行文件为目的的 Go 项目结构2.3. 以只构建库为目的的 Go 项目结构2.4. 关于 internal 目录1. Go 项目的项目结构 截至 Go 项目 commit 1e3ffb0c （2019.5.14），Go 项目结构如下： $ tree -LF 1 ~/go/src/github.com/golang/go ./go ├── api/ ├── AUTHORS ├── CONTRIBUTING.md ├── CONTRIBUTORS ├── doc/ ├── favicon.ico ├── lib/ ├── LICENSE ├── misc/ ├── PATENTS ├── README.md ├── robots.txt ├── src/ └── test 2. Go 语言典型项目结构 2.1. Go 项目结构的最小标准布局 作为 Go 语言项目的技术负责人，Russ Cox 在一个开源项目的 issue 中给出了他关于 Go 项目结构的最小标准布局的想法。他认为 Go 项目的 最小标准布局 应该是这样的： // 在Go项目仓库根路径下 - go.mod - LICENSE - xx.go - yy.go ... // 或者 - go.mod - LICENSE - package1 - package1.go - package2 - package2.go ... 2.2. 以构建二进制可执行文件为目的的 Go 项目结构 2.3. 以只构建库为目的的 Go 项目结构 2.4. 关于 internal 目录 对于不想暴露给外部引用，仅限项目内部使用的包，在项目结构上可以通过internal包机制来实现： $tree -F ./chapter2/sources/GoLibProj GoLibProj ├── LICENSE ├── Makefile ├── README.md ├── go.mod ├── internal/ │ ├── ilib1/ │ └── ilib2/ ├── lib.go ├── lib1/ │ └── lib1.go └── lib2/ └── lib2.go 根据 Go internal 机制的作用原理，internal 目录下的 ilib1、 ilib2 可以被以 GoLibProj 目录为根目录的其他目录下的代码（⽐如 lib.go、lib1/lib1.go 等）所导入和使用，但是却不可以为 GoLibProj 目录 以外的代码所使用，从而实现选择性地暴露 API 包。 By YangXin Xu            updated 2023-10-03 21:29:37 "},"第6条-提交前使用gofmt格式化源码.html":{"url":"第6条-提交前使用gofmt格式化源码.html","title":"第6条-提交前使用gofmt格式化源码","keywords":"","body":"1. gofmt：Go 语言在解决规模化问题上的最佳实践2. 使用 gofmt2.1. 使用 gofmt -s 选项简化代码2.2. 使用 gofmt -r 执行代码“微重构”2.3. 使用 gofmt -l 按格式要求输出满足条件的文件列表3. 使用 goimports4. 将 gofmt/goimports 与 IDE 或编辑器⼯具集成1. gofmt：Go 语言在解决规模化问题上的最佳实践 gofmt 的代码风格不是某个人的最爱，而是所有人的最爱。 ——Rob Pike gofmt 先入为主地将一种统一的代码风格内置到 Go 语言之中，并将其与 Go 语言一起以一种“标准”的形式推广给所有 Go 开发者。 gofmt 代码风格已经成为 Go 开发者的共识，融入 Go 语言的开发文化当中，以至于多数 Go 开发者可能说不出 gofmt 代码风格是什么样的，因为代码会被 gofmt 自动变成那种风格，大家已经不再关心风格。 很多主流语言在效仿 Go 语言而推出自己的格式化工具，⽐如 Java formatter、Clang formatter、Dartfmt 等。 2. 使用 gofmt $ gofmt -help usage: gofmt [flags] [path ...] -cpuprofile string write cpu profile to this file -d display diffs instead of rewriting files -e report all errors (not just the first 10 on different lines) -l list files whose formatting differs from gofmt's -r string rewrite rule (e.g., 'a[b:len(a)] -> a[b:]') -s simplify code -w write result to (source) file instead of stdout gofmt 最⼤的特点是没有提供任何关于代码风格设置的命令行选项和参数，这样 Go 开发人员就无法通过设置命令行特定选项来定制自己喜好的风格。 2.1. 使用 gofmt -s 选项简化代码 通过 gofmt -s 可以将遗留代码中的非简化代码自动转换为简化写法，并且没有副作用，因此一般“-s”选项都会是 gofmt 执行的默认选项。 2.2. 使用 gofmt -r 执行代码“微重构” gofmt -r 'pattern -> replacement' [other flags] [path ...] gofmt 除了具有格式化代码的功能外，对代码重构也具有一定的支撑能力。我们可以通过-r 命令行选项对代码进行表达式级别的替换，以达到重构的目的。 2.3. 使用 gofmt -l 按格式要求输出满足条件的文件列表 $ gofmt -l $GOROOT/src $GOROOT/src/cmd/cgo/zdefaultcc.go $GOROOT/src/cmd/go/internal/cfg/zdefaultcc.go $GOROOT/src/cmd/go/internal/cfg/zosarch.go ... $GOROOT/src/go/build/zcgo.go gofmt 提供了-l 选项，可以按格式要求输出满足条件的文件列表。 3. 使用 goimports Go 编译器在编译源码时会对源码文件导入的包进行检查，对于源文件中没有使用但却导入了的包或使用了但没有导入的包，Go 编译器都会报错。遗憾的是，gofmt 工具无法自动增加或删除文件头部的包导入列表。为此，Go 核心团队的 Brad Fitzpatrick 实现了 goimports，该工具后来被移到官方仓库 golang.org/x/tools/cmd/goimports 下维护了。 安装 goimports： $go get golang.org/x/tools/cmd/goimports $ ./goimports -help usage: goimports [flags] [path ...] -cpuprofile string CPU profile output -d display diffs instead of rewriting files -e report all errors (not just the first 10 on different lines) -format-only if true, don't fix imports and only format. In this mode, goimports is effectively gofmt, with the addition that imports are grouped into sections. -l list files whose formatting differs from goimport's ... 4. 将 gofmt/goimports 与 IDE 或编辑器⼯具集成 (略) By YangXin Xu            updated 2023-10-03 21:27:46 "},"第7条-使用Go命名惯例对标识符进行命名.html":{"url":"第7条-使用Go命名惯例对标识符进行命名.html","title":"第7条-使用Go命名惯例对标识符进行命名","keywords":"","body":"1. 简单且一致1.1. 包1.2. 变量、类型、函数和方法1.3. 常量1.4. 接口2. 利用上下⽂环境，让最短的名字携带足够多的信息 计算机科学中只有两件难事：缓存失效和命名。 ——Phil Karlton，Netscape 架构师 Go 的设计哲学之一就是追求简单，它在命名上一样秉承着简单的总体原则。 但简单并不意味着一味地为标识符选择短小的名字，而是要选择那种可以在标识符所在上下文中保持其用途清晰明确的名字。 Go 及其标准库的实现是 Go 命名惯例形成的源头，因此如果要寻找良好 命名的示范，Go 标准库是一个不错的地方。 1. 简单且一致 1.1. 包 对于 Go 中的包，一般建议以小写形式的单个单词命名； 我们在给包命名时不要有是否与其他包重名的顾虑，因为在 Go 中，包名可以不唯一； Go 语言建议，包名应尽量与包导入路径的最后一个路径分段保持一致； 我们在给包命名的时候，不仅要考虑包自身的名字，还要兼顾该包导出的标识符（如变量、常量、类型、函数等）的命名； 1.2. 变量、类型、函数和方法 Go 语言官方要求标识符命名采用驼峰命名法：非公开的使用小驼峰，公开的使用大驼峰； 循环和条件变量多采用单个字母命名（具体见上⾯的统计数据）； 函数/方法的参数和返回值变量以单个单词或单个字母为主； 由于方法在调用时会绑定类型信息，因此方法的命名以单个单词为主； 函数多以多单词的复合词进行命名； 类型多以多单词的复合词进行命名。 变量名字中不要带有类型信息 保持简短命名变量含义上的⼀致性 1.3. 常量 但在 Go 语言中，常量在命名方式上与变量并无较大差别，并不要求全部大写； 只是考虑其含义的准确传递，常量多使用多单词组合的方式命名； 可以对名称本身就是全大写的特定常量使用全大写的名字； 1.4. 接口 在 Go 语言中，对于接口类型优先以单个单词命名； 对于拥有唯一⽅法或通过多个拥有唯一方法的接口组合而成的接口， Go 语言的惯例是用“方法名+er”命名 2. 利用上下⽂环境，让最短的名字携带足够多的信息 在不影响可读性的前提下，兼顾一致性原则，尽可能地用短小的名字命名标识符。 // 不好的命名 func RuneCount(buffer []byte) int { runeCount := 0 for index := 0; index By YangXin Xu            updated 2023-10-03 21:31:20 "},"第8条-使用一致的变量声明形式.html":{"url":"第8条-使用一致的变量声明形式.html","title":"第8条-使用一致的变量声明形式","keywords":"","body":"1. 包级变量的声明形式1.1. 声明并同时显式初始化1.2. 声明但延迟初始化1.3. 声明聚类与就近原则2. 局部变量的声明形式2.1. 延迟初始化的局部变量声明2.2. 声明且显式初始化的局部变量2.3. 尽量在分支控制处应用短变量声明形式3. 小结1. 包级变量的声明形式 包级变量只能使用带有 var 关键字的变量声明形式 1.1. 声明并同时显式初始化 此类包级变量在实践中多使用如下格式 var variableName = InitExpression 如果想要显式为包级变量指定类型，Go 语言官方更推荐下面的第二种方式： // 第一种 var a int32 = 17 var a = int32(17) 1.2. 声明但延迟初始化 对于声明时并不显式初始化的包级变量，我们使用最基本的声明形式： var a int 32 1.3. 声明聚类与就近原则 推荐将同一类的变量声明放在一个 var 块中；或者将延迟初始化的变量声明放在一个 var 块中 // $GOROOT/src/net/http/server.go var ( bufioReaderPool sync.Pool bufioWriter2kPool sync.Pool bufioWriter4kPool sync.Pool ) var copyBufPool = sync.Pool { New: func() interface{} { b := make([]byte, 32*1024) return &b }, } ... // $GOROOT/src/net/net.go var ( aLongTimeAgo = time.Unix(1, 0) noDeadline = time.Time{} noCancel = (chan struct{})(nil) ) var threadLimit chan struct{} ... 在实践中，是否应当将包级变量的声明全部集中于源文件头部呢？或者遵守 就近原则 ，尽可能在靠近第一次使用变量的位置声明该变量 如果一个包级变量仅在一处使用，则遵守就近原则；如果一个包级变量在包内部被多处使用，则放在源文件头部更好 2. 局部变量的声明形式 相比于包级变量，局部变量多了一种短变量声明形式。 2.1. 延迟初始化的局部变量声明 采用带有 var 关键字的声明形式 // $GOROOT/src/strings/replace.go func (r *byteReplacer) Replace(s string) string { var buf []byte // 延迟分配 for i := 0; i 2.2. 声明且显式初始化的局部变量 建议使用短变量声明形式 a := int32(17) f := float32(3.14) s := []byte(\"hello, gopher!\") 2.3. 尽量在分支控制处应用短变量声明形式 // $GOROOT/src/net/net.go func (v *Buffers) WriteTo(w io.Writer) (n int64, err error) { // 笔者注：在if循环控制语句中使用短变量声明形式 if wv, ok := w.(buffersWriter); ok { return wv.writeBuffers(v) } // 笔者注：在for条件控制语句中使用短变量声明形式 for _, b := range *v { nb, err := w.Write(b) n += int64(nb) if err != nil { v.consume(n) return n, err } } v.consume(n) return n, nil } 3. 小结 By YangXin Xu            updated 2023-10-03 21:31:42 "},"第9条-使用无类型常量简化代码.html":{"url":"第9条-使用无类型常量简化代码.html","title":"第9条-使用无类型常量简化代码","keywords":"","body":"1. Go常量溯源2. 有类型常量带来的烦恼3. 无类型常量消除烦恼，简化代码4. 小结1. Go常量溯源 早期C语言使用宏来指代字面值，即所谓 宏定义常量 #define MAX_LEN 0x12345678 #define CMCC_SERVICE_PHONE_NUMBER 10086 #define PI 3.1415926 #define WELCOME_TO_GO \"Hello, Gopher\" #define A_CHAR 'a' 宏定义的缺点： 仅是预编译阶段进行替换的字面值，继承了宏替换的复杂性和易错性 是类型不安全的 无法在调试时通过宏名字输出常量的值 C语言中的const修饰的标识符本质上仍是变量。因此编译器不能像对待真正的常量那样对其进行代码优化 Go语言中的const整合了 C语言中的宏定义常量 、const只读变量 、枚举常量 三种形式，并消除了每种形式的不足，使得Go常量成为 类型安全 且 对编译器优化友好的语法元素。 绝大多数情况下，Go常量在声明时并不显式指定类型，即所谓无类型常量： // $GOROOT/src/io/io.go const ( SeekStart = 0 SeekCurrent = 1 SeekEnd = 2 ) 2. 有类型常量带来的烦恼 Go是对类型安全要求十分严格的编程语言。即使两个类型拥有相同的底层类型，仍视作毫无关系的两个类型，无法进行 隐式转换 ： type myInt int func main() { var a int = 5 var b myInt = 6 fmt.Println(a + b) // 编译器会给出错误提⽰：invalid operation: // a + b (mismatched types int and myInt) fmt.Println(a + int(b)) // 输出: 11 } 因此有类型常量会给代码简化带来麻烦，这也是Go语言对类型安全严格要求的结果 3. 无类型常量消除烦恼，简化代码 Go语言的无类型常量拥有像字面值一样的特性：可以在参与变量赋值和计算过程时无需显式类型转换，从而达到简化代码的目的 const ( a = 5 pi = 3.1415926 s = \"Hello, Gopher\" c = 'a' b = false ) type myInt int type myFloat float32 type myString string func main() { var j myInt = a var f myFloat = pi var str myString = s var e float64 = a + pi fmt.Println(j) // 输出：5 fmt.Println(f) // 输出：3.1415926 fmt.Println(str) // 输出：Hello, Gopher fmt.Printf(\"%T, %v\\n\", e, e) // float64, 8.1415926 } 无类型常量并不是没有类型，它们也拥有自己的默认类型：⽆类型的布尔型 常量、整数常量、字符常量、浮点数常量、复数常量、字符串常量对 应的默认类型分别为bool、int、int32(rune)、float64、complex128和 string。 4. 小结 所有常量表达式的求值计算都可以在编译器而不是在运行期完成，这样既可以减少运行时间，也可以方便编译器进行编译优化，甚至可以筛选出部分运行时错误 By YangXin Xu            updated 2023-10-03 17:55:26 "},"第10条-使用iota实现枚举常量.html":{"url":"第10条-使用iota实现枚举常量.html","title":"第10条-使用iota实现枚举常量","keywords":"","body":" C家族中的主流编程语言都提供定义枚举常量的语法： // C语法 enum Weekday { SUNDAY, MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY }; int main() { enum Weekday d = SATURDAY; printf(\"%d\\n\", d); // 6 } 枚举的存在满足了以下两个现实需求： 有限数量标识符构成的集合 注重类型安全 然而Go语言并没有提供定义枚举常量的语法，它使用常量语法定义枚举常量： const ( Sunday = 0 Monday = 1 Tuesday = 2 Wednesday = 3 Thursday = 4 Friday = 5 Saturday = 6 ) Go的const语法还提供了“隐式重复上一个非空表达式”的机制： const ( Apple, Banana = 11, 22 Strawberry, Grape Pear, Watermelon ) // 等价于 const ( Apple, Banana = 11, 22 Strawberry, Grape = 11, 22 Pear, Watermelon = 11, 22 ) Go在此机制的基础上又提供了 iota ：iota是Go语言的一个预定义标识符，表示的是const声明块中每个常量所处位置在块中的偏移值 // $GOROOT/src/sync/mutex.go (go 1.12.7) const ( mutexLocked = 1 Go的枚举常量不限于整型值，也可以定义浮点型的枚举常量 const ( PI = 3.1415926 // π PI_2 = 3.1415926 / (2 * iota) // π/2 PI_4 // π/4 ) iota使得维护枚举常量列表十分容易 const ( _ = iota Blue Black Red Yellow ) 最后，我们可以使用有类型枚举常量来保证类型安全 // $GOROOT/src/time/time.go type Weekday int const ( Sunday Weekday = iota Monday Tuesday Wednesday Thursday Friday Saturday ) By YangXin Xu            updated 2023-10-03 18:40:09 "},"第11条-尽量定义零值可用的类型.html":{"url":"第11条-尽量定义零值可用的类型.html","title":"第11条-尽量定义零值可用的类型","keywords":"","body":"1. Go类型的零值2. 零值可用3. 小结 保持零值可用。 ——Go 谚语 1. Go类型的零值 在C99规范中，有一段是否对栈上局部变量进行自动清零初始化的描述： 未被显式初始化且具有自动存储持续时间的对象，其值是不确定的。 Go语言规范中刮愈变了默认值的描述： 当通过声明或调用new为变量分配存储空间，或者通过复合文字字面量或调用make创建新值，且不提供显式初始化时，Go会为变量或值提供默认值（即零值） 2. 零值可用 Go从诞生以来就一直拼成这尽量保持“零值可用”的的理念 例一： var zeroSlice []int zeroSlice = append(zeroSlice, 1) zeroSlice = append(zeroSlice, 2) zeroSlice = append(zeroSlice, 3) fmt.Println(zeroSlice) // 输出：[1 2 3] 并未显式初始化的切片zeroSlice初值为nil，但却可以直接对其进行append操作，而不会出现引用nil的错误 例二： // chapter3/sources/call_method_through_nil_pointer.go func main() { var p *net.TCPAddr fmt.Println(p) //输出： } // $GOROOT/src/net/tcpsock.go func (a *TCPAddr) String() string { if a == nil { return \"\" } ip := ipEmptyString(a.IP) if a.Zone != \"\" { return JoinHostPort(ip+\"%\"+a.Zone, itoa(a.Port)) } return JoinHostPort(ip, itoa(a.Port)) } 可以看到Go标准库在定义TCPAddr类型及其方法时充分考虑了零值可用的理念，使得通过值为nil的TCPAddr指针变量依然可以调用String()方法 3. 小结 Go语言“零值可用”的理念给内置类型、标准库的使用者带来很多便利。 不过Go并非所有类型都是零值可用的，并且零值可用也有一定的限制： var s []int s[0] = 12 // 报错！ s = append(s, 12) // 正确 var m map[string]int m[\"go\"] = 1 // 报错！ m1 := make(map[string]int) m1[\"go\"] = 1 // 正确 By YangXin Xu            updated 2023-10-03 19:13:25 "},"第12条-使用复合字面值作为初值构造器.html":{"url":"第12条-使用复合字面值作为初值构造器.html","title":"第12条-使用复合字面值作为初值构造器","keywords":"","body":"1. 结构体复合字面值2. 数组 / 切片复合字面值3. map复合字面值 Go提供的复合字面值（composite literal）语法可以作为复合类型变量的初值构造器。 var s myStruct s.name = \"tony\" s.age = 23 var a [5]int a[0] = 13 a[1] = 14 ... a[4] = 17 sl := make([]int, 5, 5) sl[0] = 23 sl[1] = 24 ... sl[4] = 27 m := make(map[int]string) m[1] = \"hello\" m[2] = \"gopher\" m[3] = \"!\" // 使用复合字面值进行简化 s := myStruct{\"tony\", 23} a := [5]int{13, 14, 15, 16, 17} sl := []int{23, 24, 25, 26, 27} m := map[int]string {1:\"hello\", 2:\"gopher\", 3:\"!\"} 1. 结构体复合字面值 Go推荐使用 field:value 的复合字面值形式对 struct 类型变量进行值构造。这种值构造方式可以降低 结构体类型使用者 与 结构体类型设计者 之间的耦合，这也是Go语言的惯用法 field:value 形式字面值中的字段可以以任意次序出现，未显式出现在字面值的结构体中的字段将采用其对应类型的零值 不允许将从其他包导入的结构体中的未导出字段作为复合字面值中的field，这会导致编译错误 2. 数组 / 切片复合字面值 数组 / 切片使用下标作为field，从而实现其高级构造形式： numbers := [256]int{'a': 8, 'b': 7, 'c': 4, 'd': 3, 'e': 2, 'y': 1, 'x': 5} // [10]float{-1, 0, 0, 0, -0.1, -0.1, 0, 0.1, 0, -1} fnumbers := [...]float{-1, 4: -0.1, -0.1, 7:0.1, 9: -1} // $GOROOT/src/sort/search_test.go var data = []int{0: -10, 1: -5, 2: 0, 3: 1, 4: 2, 5: 3, 6: 5, 7: 7, 8: 11, 9: 100, 10: 100, 11: 100, 12: 1000, 13: 10000} var sdata = []string{0: \"f\", 1: \"foo\", 2: \"foobar\", 3: \"x\"} 3. map复合字面值 由于map类型具有原生的 key:value 构造形式，因此使用复合字面值作为初值构造器就显得自然许多。 // $GOROOT/src/time/format.go var unitMap = map[string]int64{ \"ns\": int64(Nanosecond), \"us\": int64(Microsecond), \"µs\": int64(Microsecond), // U+00B5 = 微符号 \"μs\": int64(Microsecond), // U+03BC = 希腊字⺟μ \"ms\": int64(Millisecond), ... } // $GOROOT/src/net/http/server.go var stateName = map[ConnState]string{ StateNew: \"new\", StateActive: \"active\", StateIdle: \"idle\", StateHijacked: \"hijacked\", StateClosed: \"closed\", } By YangXin Xu            updated 2023-10-03 20:25:13 "},"第13条-了解切片实现原理并高效使用.html":{"url":"第13条-了解切片实现原理并高效使用.html","title":"第13条-了解切片实现原理并高效使用","keywords":"","body":"1. 切片究竟是什么2. 切片的高级特性：动态扩容3. 尽量使用cap参数创建切片 每当你花费大量时间使用某种特定工具时，深入了解它并了解如何高效使用它是很值得的 1. 切片究竟是什么 Go语言数组是一个 固定长度的 、容纳同构类型元素的 连续序列。因此Go数组类型具有两个属性： 元素类型和数组长度 ，只有两个属性都相同的数组类型才是等价的 Go数组都是 值语义 ，即一个数组变量表示的是整个数组。而不是像C语言一样，数组变量还可以被视作指向数组第一个元素的指针。 切片之于数组就像是文件描述符之于文件：数组更多是退居幕后充当底层容器的角色；而切片更多是走向台前充当 访问底层容器的窗口 的角色： 切片在Go运行时层面的内部表示： //$GOROOT/src/runtime/slice.go type slice struct { array unsafe.Pointer // 指向下层数组某元素的指针，该元素也是切⽚的起始元素 len int // 切⽚的⻓度，即切⽚中当前元素的个数 cap int // 切⽚的最⼤容量 } 切片的创建： 数组的切片化： 共享数组的多切片访问： 切片的reslicing： 无论切片描述的底层数组有多大，作为参数传递的切片带来的性能存好都是很小且恒定的 切片可以提供比指针更为强大的功能，比如 下标访问 、边界溢出校验 、动态扩容 等 2. 切片的高级特性：动态扩容 // chapter3/sources/slice_append.go var s []int // s被赋予零值nil s = append(s, 11) fmt.Println(len(s), cap(s)) //1 1 s = append(s, 12) fmt.Println(len(s), cap(s)) //2 2 s = append(s, 13) fmt.Println(len(s), cap(s)) //3 4 s = append(s, 14) fmt.Println(len(s), cap(s)) //4 4 s = append(s, 15) fmt.Println(len(s), cap(s)) //5 8 append会根据切片的需要，在当前底层数组容量无法满足的情况下，动态分配新数组，新数组长度会按一定算法扩展。 新数组建立后，会将原数组数据复制到新数组中，再让切片指向新的底层数组，最后将原数组GC掉。 因此：当切片触碰到底层数组的上界时，继续添加元素会令切片的底层数组不在是原来的底层数组，从而会出现 切片和底层数组的隐式解除绑定的现象 。 3. 尽量使用cap参数创建切片 基于上面的原理，在创建新切片时，将预估的切片容量数据一cap参数传递给make，可以减少内存分配和数据移动的次数，从而提高性能。 By YangXin Xu            updated 2023-10-03 21:21:52 "},"第14条-了解map实现原理并高效使用.html":{"url":"第14条-了解map实现原理并高效使用.html","title":"第14条-了解map实现原理并高效使用","keywords":"","body":"1. 什么是map2. map的基本操作3. map的内部实现3.1. 初始状态3.1.1. tophash区域3.1.2. key存储区域3.1.3. value存储区域3.2. map扩容3.3. map和并发4. 尽量使用cap参数创建map5. 小结1. 什么是map map对value的类型没有限制，但对key的类型有严格要求：key的类型应该杨哥定义了多为 “==” 和 “!=” 两个操作符的操作数是的行为 。 因此函数、map、切片不能作为map的key类型 map类型不支持零值可用。因此对处于零值状态的map变量会导致运行时panic： var m map[string]int // m = nil m[\"key\"] = 1 // panic: assignment to entry in nil map 创建map类型变量有两种方式： 使用复合字面值创建map类型变量 // $GOROOT/src/net/status.go var statusText = map[int]string{ StatusOK: \"OK\", StatusCreated: \"Created\", StatusAccepted: \"Accepted\", ... } 使用make创建map类型变量 // $GOROOT/src/net/client.go icookies = make(map[string][]*Cookie) // $GOROOT/src/net/h2_bundle.go http2commonLowerHeader = make(map[string]string, len(common)) map也是引用类型，将其作为参数传入不会有很大的性能损耗。 2. map的基本操作 (略) 注意：对map做多次遍历，遍历的元素次序并不相同。 3. map的内部实现 在编译阶段Go编译器会将语法层面的map操作重写成运行时对应的函数调用： // $GOROOT/src/cmd/compile/internal/gc/walk.go // $GOROOT/src/runtime/map.go m := make(map[keyType]valType, capacityhint) → m := runtime.makemap(maptype, capacityhint, m) v := m[\"key\"] → v := runtime.mapaccess1(maptype, m, \"key\") v, ok := m[\"key\"] → v, ok := runtime.mapaccess2(maptype, m, \"key\") m[\"key\"] = \"value\" → v := runtime.mapassign(maptype, m, \"key\") // v是⽤于后续存储value 的空间的地址 delete(m, \"key\") → runtime.mapdelete(maptype, m, \"key\") 下图是map类型在运行时层实现的示意图： 3.1. 初始状态 hmap 是map类型的header，可以理解为map类型的描述符，他存储了后序map类型操作所需的所有信息 count ：当前map中的元素个数；也是len的返回值； flags ：当前map所处的状态标志，目前定义了4个状态值——iterator 、oldIterator 、hashWriting 、sameSizeGrow B ：是bucket数量的以2为底的对数 noverflow ：overflow bucket 的大约数量 hash0 ：哈希函数的种子值 buckets ：指向bucket数组的指针 oldbuckets ：在map扩容阶段指向旧bucket数组的指针 nevacuate ：在map扩容阶段充当扩容进度计数器。所有下标小于nevacuate的bucket都已经完成了数据排空和迁移操作 extra ：可选字段 bucket（桶）是用来真正存储键值对数据的容器，每个bucket存储的是Hash值低bit位数值相同的元素，默认容量为 BUCKETSIZE （值为8）； 当桶满且map尚未达到扩容条件时，运行时会建立overflow bucket链表挂在对应的bucket尾部； 每个bucket由三部分组成：tophash 、key 、value 3.1.1. tophash区域 运行时map会通过哈希函数对key做哈希运算并获得一个哈希值 hashcode 。 其低位值作为索引用于选定bucket，高位值作为tag用于精切匹配 3.1.2. key存储区域 当我们声明一个map类型变量时，Go运行时就会为该变量对应的特定map类型生成一个 runtime.maptype 实例： // $GOROOT/src/runtime/type.go type maptype struct { typ _type key *_type elem *_type bucket *_type // 表⽰hash bucket的内部类型 keysize uint8 // key的⼤⼩ elemsize uint8 // elem的⼤⼩ bucketsize uint16 // bucket的⼤⼩ flags uint32 } maptype的存在让Go在所有map类型共享一套运行时map操作函数，从而减少了最终二进制文件空间的占用 3.1.3. value存储区域 Go运行时采用了将key和value分开存储的策略，而非采用kv紧邻存储方案。这带来了算法上的复杂性，但减少了因为内存对齐带来的内存浪费： 如果key或value的数据长度超过一定数值，那么运行时不会再bucket中直接存储数据，而是会存储key或value的指针 3.2. map扩容 map扩容的时机： “overflow bucket” 过多导致的扩容 ：运行时会新建一个和现有规模一样的bucket数组，然后在进行assign和delete操作时进行排空和迁移。即所谓重新分配 “count > LoadFactor(负载因子) * 2^B ” 导致的扩容 ：运行时会建立一个两倍于现有规模的新bucket数组，原bucket数组会挂在oldbuckets指针下，新bucket数组则会挂在buckets指针下。真正的排空和迁移工作也是在进行assign和delete操作时逐步进行的。 3.3. map和并发 map实例不是并发写安全的，不支持并发读写；如果对其进行并发读写，会产生运行时panic；但是map是可以并发读的 Go1.9中引入了支持并发安全的 sync.Map 类型 由于map会自动扩容，所以Go不允许获取map中value的地址 4. 尽量使用cap参数创建map 如果可能的话，我们最好对map使用规模做出粗略的估算，并使用cap参数对map实例进行初始化。 5. 小结 在日常使用map的场合要把握住下面几个要点： 不要依赖map的元素遍历顺序； map不是线程安全的，不支持并发写； 不要尝试获取map中元素（value）的地址； 尽量使用cap参数创建map，以提升map平均访问性能，减少频繁扩容带来的不必要损耗。 By YangXin Xu            updated 2023-10-04 00:38:42 "}}