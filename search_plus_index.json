{"./":{"url":"./","title":"Introduction","keywords":"","body":"1. Introduction1. Introduction 这是我的《Go语言精进之路》的读书笔记的gitbook，会时不时更新。 By YangXin Xu            updated 2023-10-03 15:33:39 "},"第1条-了解Go语言的诞生和演进.html":{"url":"第1条-了解Go语言的诞生和演进.html","title":"第1条-了解Go语言的诞生和演进","keywords":"","body":"1. Go语言的诞生2. Go语言的早期团队和演进历程3. Go语言正式发布并开源1. Go语言的诞生 2009年9月20日，以下三位谷歌的大佬进行了一次有关设计一门新编程语言的讨论 Rob Pike：贝尔实验室早期成员，参与了Plan 9操作系统、C编译器和多种语言编译器的设计和实现，UTF-8的发明者之一 Robert Griesemer：Java的HotSpot虚拟机和Chrome浏览器的JavaScript V8引擎的设计者之一 Ken Thompson：图灵机得主，Unix之父，C语言的发明者之一 随后经过几次讨论和会议，Robert Griesemer 发出了一封题为 “prg lang discussion” 的电邮，对讨论进行了归纳总结：在C语言的基础上，修正明显的缺陷、删除被诟病的特性、增加缺失的功能： 使用 import 替代 include 去除宏 用一个源文件替代.h和.c文件，自动提取模块接口 语句像C语言一样，但需修正switch语句 表达式像C语言一样，但有些注意事项 基本上是强类型的，但需支持运行时类型 数组应该有边界检查 具备GC机制 支持接口 支持嵌套和匿名函数/闭包 一个简单的编译器 各种语言机制应该能产生可预测代码 golang仅应用于命名G语言官方网站，因为当时go.com域名被迪士尼公司占用 2. Go语言的早期团队和演进历程 2008年年初，Ken Thompson 实现了第一版Go编译器。此编译器先将Go代码转换为C代码，再由C编译器编译成二进制文件 2008年年中，同样在谷歌工作的 Ian Lance Taylor 为Go语言实现了一个GCC的前端，成为了Go语言的第二个编译器。随后他以第四位成员的身份正式加入Go语言开发团队 Russ Cox 是第五位加入Go语言开发团队的成员。他利用函数类型也可以拥有自己的方法这个特性巧妙设计出了http包的HandlerFunc类型 3. Go语言正式发布并开源 2009年10月30日，Rob Pike 在 Google Techtalk 上做了一次有关Go语言的演讲——The Go Programming Language ，首次将Go语言公之于众 2009年11月10日，G语言项目正式开源，开源后的Go语言吸引力全世界开发者的目光，越来越多贡献者开始为Go语言添砖加瓦 Go语言开源后，许多云计算领域的大厂和初创公司成为Go语言的早期接纳者，并产生了一系列杀手级项目：容器引擎Docker、云原生实施标准平台Kubernetes、服务网格Istio、区块链公链以太坊(Ethereum)、联盟链超级账本(Hyperledger Fabric)、分布式关系型数据库TiDB和CockroachDB、云原生监控系统Prometheus等 By YangXin Xu            updated 2023-10-03 13:00:54 "},"第2条-选择适当的Go语言版本.html":{"url":"第2条-选择适当的Go语言版本.html","title":"第2条-选择适当的Go语言版本","keywords":"","body":"1. Go语言的先祖2. Go语言的版本发布历史3. Go语言的版本选择建议1. Go语言的先祖 Go继承了诸多编程语言的特性： Go的基本语法参考了C语言，是”C家族语言“的一个分支 Go的声明语法、包概念则受到了Pascal、Modula、Oberon的启发 ⼀ 些并发的思想则来自受到Tony Hoare教授CSP理论影响的编程语言 2. Go语言的版本发布历史 (略) 3. Go语言的版本选择建议 Go开发团队一直建议大家使用最新的发布版 而开源社区则倾向于使用最新版本之前的哪个版本 By YangXin Xu            updated 2023-10-03 13:11:22 "},"第3条-理解Go语言的设计哲学.html":{"url":"第3条-理解Go语言的设计哲学.html","title":"第3条-理解Go语言的设计哲学","keywords":"","body":"1. 追求简单，少即是多2. 偏好组合，正交解耦3. 原生并发，轻量高效4. 面向工程，“自带电池”4.1. 语言4.2. 标准库4.3. 工具链1. 追求简单，少即是多 简单是一种伟大的美德，但我们需要更艰苦地努⼒才能实现它，并需要经过一个教育的过程才能去欣赏和领会它。但糟糕的是：复杂的东⻄似乎更有市场。 ——Edsger Dijkstra，图灵奖得主 Go语言实际上是很复杂的，但只是让大家感觉很简单 ——Rob Pike，Go语言之父 Go的设计者们在语言设计之初就 拒绝走语言特性融合的道路，而选择了“做减法”，选择了“简单”，他们把复杂性留给了语言自身的设计和实现（Go核心开发组自己），而将简单、易用和清晰留给了广大Gopher： 简洁、常规的语法（不需要解析符号表），它仅有25个关键字； 内置垃圾收集，降低开发人员内存管理的心智负担； 没有头文件； 显式依赖（package）； 没有循环依赖（package）； 常量只是数字； 首字母大小写决定可见性； 任何类型都可以拥有方法（没有类）； 没有子类型继承（没有子类）； 没有算术转换； 接口是隐式的（无须implements声明）； 方法就是函数； 接口只是方法集合（没有数据）； 方法仅按名称匹配（不是按类型）； 没有构造函数或析构函数； n++和n--是语句，而不是表达式； 没有++n和--n； 赋值不是表达式； 在赋值和函数调用中定义的求值顺序（无“序列点”概念）； 没有指针算术； 内存总是初始化为零值； 没有类型注解语法（如C++中的const、static等）； 没有模板/泛型； 没有异常（exception）； 内置字符串、切片（slice）、map类型； 内置数组边界检查； 内置并发支持； Go设计者推崇 “最小方式”思维 ：即一件事情仅有一种方式或数量尽可能少的方式去完成，这大大减少了开发人员在选择路径方式及理解他人所选路径方式上的心智负担 在Go演化进入关键阶段（走向Go 2）的今天，有人向Go开发团队提出过这样一个问题：Go后续演化的最大难点是什么？Go开发团队的一名核心成员回答道：“最大的难点是如何继续保持Go语言的简单。” 2. 偏好组合，正交解耦 当我们有必要采用另一种方式处理数据时，我们应该有一些耦合程序的方式，就像花园⾥将浇⽔的软管通过预置的螺丝扣拧入另一段那样，这也是Unix IO采用的方式。 ——Douglas McIlroy，Unix管道的发明者（1964） Go语言本质上不属于经典OO语言范畴。Go语言遵从的设计哲学是组合，通过组合将程序各个部分有机耦合在一起 在语言设计层面，Go提供了正交的语法元素供后续组合使用，包括： Go语言无类型体系（type hierarchy），类型之间是独⽴的，没有子类型的概念； 每个类型都可以有自己的方法集合，类型定义与方法实现是正交独立的； 接口（interface）与其实现之间隐式关联； 包（package）之间是相对独立的，没有子包的概念； Go语言为我们呈现了这样一幅图景：一座座没有关联的“孤岛”，但每个岛内又都很精彩。现在摆在面前的工作就是以最适当的方式在这些孤岛之间建立关联（耦合），形成一个整体。Go采用了组合的方式，也是唯一的方式 Go语言提供的最为直观的组合的语法元素是 类型嵌入（type embedding） 。通过类型嵌入，我们可以将已经实现的功能嵌入新类型中，以快速满足新类型的功能需求。我们也可以称之为 垂直组合 interface 是Go语言中真正的“魔法”，是Go语言的一个创新设计， 它只是方法集合，且与实现者之间的关系是隐式的，它让程序各个部 分之间的耦合降⾄最低，同时是连接程序各个部分的“纽带”。隐式的interface实现会不经意间自然而然地满足依赖抽象、里氏替换、接口隔离等设计原则。我们也可称之为 水平组合 综上： 组合原则的应用塑造了Go程序的骨架结构； 类型嵌入为类型提供垂直扩展能力； interface是水平组合的关键，它好比程序肌体上 的“关节”，给予连接“关节”的两个部分各自“自由活动”的能力，而整体上又实现了某种功能； 3. 原生并发，轻量高效 并发是有关结构的，而并行是有关执行的。 ——Rob Pike（2012） Go的设计者敏锐地把握了CPU向多核方向发展的这一趋势，在决定不再使用C++而去创建一门新语言的时候，果断将 面向多核、原生内置并发支持 作为新语言的设计原则之一 Go语言原生支持并发的设计哲学体现在以下几点： Go语言采用 轻量级协程并发模型，使得Go应用在面向多核硬件时更具可扩展性 Go放弃了传统的基于操作系统线程的并发模型，而采用了 用户层轻量级线程（Go称其为 goroutine） Go运行时默认每个goroutine分配的栈空间仅为2KB。goroutine调度的切换也不用陷入操作系统内核层完成，代价很低。因此，在一个Go程序中可以创建成千上万个并发的goroutine。 goroutine的调度全靠Go自己完成，实现Go程序内goroutine之间公平地竞争CPU资源的任务就落到了Go运行时头上。而将这些goroutine按照一定算法放到 CPU上执行的程序就称为 goroutine调度器 Go语言为开发者提供的支持并发的语法元素和机制： 执行单元：goroutine； 创建和销毁方式：go+函数调用；函数退出即goroutine退出； 并发goroutine的通信：通过语言内置的channel传递消息或实现同步，并通过select实现多路channel的并发控制； 并发原则对Go开发者在程序结构设计层面的影响 并发是有关结构的，它是一种将一个程序分解成多个小片段并且 每个小片段都可以独立执⾏的程序设计方法；并发程序的小片段之间一般存在通信联系并且通过通信相互协作； 并行是有关执行的，它表示同时进行一些计算任务； 并发程序的结构设计不要局限于在单核情况下处理能力的高低，而要以 在多核情况下充分提升多核利用率、获得性能的自然提升为最终目的 4. 面向工程，“自带电池” 软件工程指引着Go语言的设计。 ——Rob Pike（2012） 三位Go语言之父在设计Go语言时的初衷：面向真实世界中Google内部大规模软件开发存在的各种问题，为这些问题提供答案 在Go语言最初设计阶段就将 解决工程问题 作为Go的设计原则之一去考虑Go语法、工具链与标准库的设计，这也是Go与那些偏学院派、偏研 究性编程语言在设计思路上的一个重大差异 Go设计者将所有工程问题浓缩为一个词：scale 。Go的设计目标就是帮助开发者更容易、更高效地管理两类规模： 生产规模：用Go构建的软件系统的并发规模，比如这类系统并发关注点的数量、处理数据的量级、同时并发与之交互的服务的数 量等； 开发规模：包括开发团队的代码库的大小，参与开发、相互协作的工程师的人数等； 4.1. 语言 面向工程的语言设计细节要考量以下这些： 重新设计编译单元和目标文件格式，实现Go源码快速构建，将大工程的构建时间缩短到接近于动态语言的交互式解释的编译时间。 如果源文件导入了它不使用的包，则程序将无法编译。这既可以充分保证Go程序的依赖树是精确的，也可以保证在构建程序时不会编译额外的代码，从而最大限度地缩短编译时间。 去除包的循环依赖。循环依赖会在大规模的代码中引发问题，因为它们要求编译器同时处理更大的源文件集，这会减慢增量构建速度。 在处理依赖关系时，有时会通过允许一部分重复代码来避免引入较多依赖关系。比如：net包具有其自己的整数到十进制转换实现，以避免依赖于较大且依赖性较强的格式化io包。 包路径是唯一的，而包名不必是唯一的。导入路径必须唯一标识要导入的包，而名称只是包的使用者对如何引用其内容的约定。包名不必是唯一的约定大大降低了开发人员给包起唯一名字的心 智负担。 故意不支持默认函数参数。因为在规模工程中，很多开发者利用默认函数参数机制向函数添加过多的参数以弥补函数API的设计缺陷，这会导致函数拥有太多的参数，降低清晰度和可读性。 首字母大小写定义标识符可见性，这是Go的一个创新。它让开发人员通过名称即可知晓其可见性，而无须回到标识符定义的位置查找并确定其可见性，这提升了开发人员阅读代码的效率。 在语义层面，相对于C，Go做了很多改动，提升了语言的健壮性，比如去除指针算术，去除隐式类型转换等。 内置垃圾收集。这对于大型工程项目来说，大大降低了程序员在 内存管理方面的负担，程序员使用GC感受到的好处超过了付出的成本，并且这些成本主要由语言实现者来承担。 内置并发⽀持，为网络软件带来了简单性，而简单又带来了健壮，这是大型工程软件开发所需要的。 增加类型别名，支持大规模代码库的重构。 4.2. 标准库 Go被称为 “自带电池”（battery-included） 的编程语言 如果说⼀门编程语言“自带电池”，则说明这门语言标准库功能丰富，多数功能无须依赖第三方包或库，Go 语言恰是这类编程语言 4.3. 工具链 Go语言提供了十分全面、贴心的编程语言官方工具链，涵盖了编译、编辑、依赖获取、 调试、测试、⽂档、性能剖析等的方方面面： 构建和运行：go build/go run 依赖包查看与获取：go list/go get/go mod xx 编辑辅助格式化：go fmt/gofmt 文档查看：go doc/godoc 单元测试/基准测试/测试覆盖率：go test 代码静态分析：go vet 性能剖析与跟踪结果查看：go tool pprof/go tool trace 升级到新Go版本API的辅助工具：go tool fix 报告Go语言bug：go bug Go构建了⼀个开放的工具链生态系统，它鼓励社区和开发人员为Go添加更多、更实用的工具，而更多、更实用的工具反过来又帮助Go更好地解决工程上的“规模化”问题，这是一个良性的生态循环。 By YangXin Xu            updated 2023-10-03 14:27:22 "},"第4条-使用Go语言原生编程思维来写Go代码.html":{"url":"第4条-使用Go语言原生编程思维来写Go代码.html","title":"第4条-使用Go语言原生编程思维来写Go代码","keywords":"","body":"1. 语言与思维2. 现实的投影2.1. C语言版本2.2. Haskell版本2.3. Go语言版本3. Go语言原生编程思维1. 语言与思维 在人类自然语言学界有⼀个很著名的假说——“萨丕尔-沃夫假说”，这个假说的内容是这样的：“语言影响或决定人类的思维方式。” 2. 现实的投影 埃拉托斯特尼素数筛算法的不同语言实现 2.1. C语言版本 #include #define LIMIT 50 #define PRIMES 10 void sieve() { int c, i,j,numbers[LIMIT], primes[PRIMES]; for (i=0;i C版本的素数筛程序是⼀个常规实现。它定义了两个数组numbers 和primes，“筛”的过程在numbers这个数组中进行（基于纯内存修改），非素数的数组元素被设置为-1，便于后续提取。 2.2. Haskell版本 sieve [] = [] sieve (x:xs) = x : sieve (filter (\\a -> not $ a `mod` x == 0) xs) n = 100 main = print $ sieve [2..n] Haskell版本采⽤了函数递归的思路，通过“filter操作集合”，用谓词（过滤条件）\\a -> not $ a `mod` x == 0筛除素数的倍数，将未筛除的数的集合作为参数传递归递给下去。 2.3. Go语言版本 func Generate(ch chan Go版本程序实现了⼀个并发素数筛，它采⽤的是goroutine的并发组合。程序从素数2开始，依次为每个素数建⽴⼀个goroutine，⽤ 于作为筛除该素数的倍数。 3. Go语言原生编程思维 编程语言影响编程思维，每种编程语言都有属于自己的原生编程思维： C语言相信程序员，提供指针和指针运算，让C程序员天马行空地自由发挥，接近提出的直接内存操作让C程序拥有很高的性能 C++支持多范式（命令式、OO、泛型），推荐使用最新代表现代语言发展特色的泛型等高级范式 Python语言更是形成了Pythonic规则来指导Python程序员写出符合Python思维或惯用法的代码 By YangXin Xu            updated 2023-10-03 14:43:08 "},"第5条-使用得到工人且广泛使用的项目结构.html":{"url":"第5条-使用得到工人且广泛使用的项目结构.html","title":"第5条-使用得到工人且广泛使用的项目结构","keywords":"","body":"1. Go 项目的项目结构2. Go 语言典型项目结构2.1. Go 项目结构的最小标准布局2.2. 以构建二进制可执行文件为目的的 Go 项目结构2.3. 以只构建库为目的的 Go 项目结构2.4. 关于 internal 目录1. Go 项目的项目结构 截⾄ Go 项目 commit 1e3ffb0c （2019.5.14），Go 项目结构如下： $ tree -LF 1 ~/go/src/github.com/golang/go ./go ├── api/ ├── AUTHORS ├── CONTRIBUTING.md ├── CONTRIBUTORS ├── doc/ ├── favicon.ico ├── lib/ ├── LICENSE ├── misc/ ├── PATENTS ├── README.md ├── robots.txt ├── src/ └── test 2. Go 语言典型项目结构 2.1. Go 项目结构的最小标准布局 作为 Go 语言项目的技术负责人，Russ Cox 在一个开源项目的 issue 中给出了他关于 Go 项目结构的最小标准布局的想法。他认为 Go 项目的 最小标准布局 应该是这样的： // 在Go项⽬仓库根路径下 - go.mod - LICENSE - xx.go - yy.go ... // 或者 - go.mod - LICENSE - package1 - package1.go - package2 - package2.go ... 2.2. 以构建二进制可执行文件为目的的 Go 项目结构 2.3. 以只构建库为目的的 Go 项目结构 2.4. 关于 internal 目录 对于不想暴露给外部引用，仅限项目内部使用的包，在项目结构上可以通过internal包机制来实现： $tree -F ./chapter2/sources/GoLibProj GoLibProj ├── LICENSE ├── Makefile ├── README.md ├── go.mod ├── internal/ │ ├── ilib1/ │ └── ilib2/ ├── lib.go ├── lib1/ │ └── lib1.go └── lib2/ └── lib2.go 根据 Go internal 机制的作⽤原理，internal ⽬录下的 ilib1、 ilib2 可以被以 GoLibProj ⽬录为根⽬录的其他⽬录下的代码（⽐如 lib.go、lib1/lib1.go 等）所导⼊和使⽤，但是却不可以为 GoLibProj ⽬录 以外的代码所使⽤，从⽽实现选择性地暴露 API 包。 By YangXin Xu            updated 2023-10-03 15:32:19 "},"第6条-提交前使用gofmt格式化源码.html":{"url":"第6条-提交前使用gofmt格式化源码.html","title":"第6条-提交前使用gofmt格式化源码","keywords":"","body":"1. gofmt：Go语言在解决规模化问题上的最佳实践2. 使用gofmt2.1. 使用gofmt -s选项简化代码2.2. 使用gofmt -r执行代码“微重构”2.3. 使用gofmt -l按格式要求输出满足条件的文件列表3. 使用goimports4. 将gofmt/goimports与IDE或编辑器⼯具集成1. gofmt：Go语言在解决规模化问题上的最佳实践 gofmt的代码风格不是某个人的最爱，而是所有人的最爱。 ——Rob Pike gofmt先入为主地将一种统一的代码风格内置到Go语言之中，并将其与Go语言一起以一种“标准”的形式推广给所有Go开发者。 gofmt代码风格已经成为Go开发者的共识，融入Go语⾔的开发文化当中，以至于多数Go开发者可能说不出gofmt代码风格是什么样的，因为代码会被gofmt自动变成那种风格，大家已经不再关心风格。 很多主流语言在效仿Go语言而推出自己的格式化工具，⽐如Java formatter、Clang formatter、Dartfmt等。 2. 使用gofmt $ gofmt -help usage: gofmt [flags] [path ...] -cpuprofile string write cpu profile to this file -d display diffs instead of rewriting files -e report all errors (not just the first 10 on different lines) -l list files whose formatting differs from gofmt's -r string rewrite rule (e.g., 'a[b:len(a)] -> a[b:]') -s simplify code -w write result to (source) file instead of stdout gofmt最⼤的特点是没有提供任何关于代码风格设置的命令行选项和参数，这样Go开发人员就无法通过设置命令行特定选项来定制自己喜好的风格。 2.1. 使用gofmt -s选项简化代码 通过gofmt -s可以将遗留代码中的非简化代码自动转换为简化写法，并且没有副作用，因此一般“-s”选项都会是gofmt执行的默认选项。 2.2. 使用gofmt -r执行代码“微重构” gofmt -r 'pattern -> replacement' [other flags] [path ...] gofmt除了具有格式化代码的功能外，对代码重构也具有一定的支撑能力。我们可以通过-r命令行选项对代码进行表达式级别的替换，以达到重构的目的。 2.3. 使用gofmt -l按格式要求输出满足条件的文件列表 $ gofmt -l $GOROOT/src $GOROOT/src/cmd/cgo/zdefaultcc.go $GOROOT/src/cmd/go/internal/cfg/zdefaultcc.go $GOROOT/src/cmd/go/internal/cfg/zosarch.go ... $GOROOT/src/go/build/zcgo.go gofmt提供了-l选项，可以按格式要求输出满足条件的文件列表。 3. 使用goimports Go编译器在编译源码时会对源码文件导入的包进行检查，对于源文件中没有使用但却导入了的包或使用了但没有导入的包，Go编译器都会报错。遗憾的是，gofmt工具无法自动增加或删除文件头部的包导入列表。为此，Go核心团队的Brad Fitzpatrick实现了goimports，该工具后来被移到官方仓库golang.org/x/tools/cmd/goimports下维护了。 安装goimports： $go get golang.org/x/tools/cmd/goimports $ ./goimports -help usage: goimports [flags] [path ...] -cpuprofile string CPU profile output -d display diffs instead of rewriting files -e report all errors (not just the first 10 on different lines) -format-only if true, don't fix imports and only format. In this mode, goimports is effectively gofmt, with the addition that imports are grouped into sections. -l list files whose formatting differs from goimport's ... 4. 将gofmt/goimports与IDE或编辑器⼯具集成 (略) By YangXin Xu            updated 2023-10-03 15:14:33 "},"第7条-使用Go命名惯例对标识符进行命名.html":{"url":"第7条-使用Go命名惯例对标识符进行命名.html","title":"第7条-使用Go命名惯例对标识符进行命名","keywords":"","body":"1. 简单且一致1.1. 包1.2. 变量、类型、函数和方法1.3. 常量1.4. 接口2. 利用上下⽂环境，让最短的名字携带足够多的信息 计算机科学中只有两件难事：缓存失效和命名。 ——Phil Karlton，Netscape架构师 Go的设计哲学之一就是追求简单，它在命名上一样秉承着简单的总体原则。 但简单并不意味着一味地为标识符选择短小的名字，而是要选择那种可以在标识符所在上下文中保持其用途清晰明确的名字。 Go及其标准库的实现是Go命名惯例形成的源头，因此如果要寻找良好 命名的示范，Go标准库是一个不错的地方。 1. 简单且一致 1.1. 包 对于Go中的包，一般建议以小写形式的单个单词命名； 我们在给包命名时不要有是否与其他包重名的顾虑，因为在Go中，包名可以不唯一； Go语⾔建议，包名应尽量与包导入路径的最后一个路径分段保持一致； 我们在给包命名的时候，不仅要考虑包自身的名字，还要兼顾该包导出的标识符（如变量、常量、类型、函数等）的命名； 1.2. 变量、类型、函数和方法 Go语言官方要求标识符命名采用驼峰命名法：非公开的使用小驼峰，公开的使用大驼峰； 循环和条件变量多采用单个字母命名（具体见上⾯的统计数据）； 函数/方法的参数和返回值变量以单个单词或单个字母为主； 由于方法在调用时会绑定类型信息，因此方法的命名以单个单词为主； 函数多以多单词的复合词进行命名； 类型多以多单词的复合词进行命名。 变量名字中不要带有类型信息 保持简短命名变量含义上的⼀致性 1.3. 常量 但在Go语⾔中，常量在命名方式上与变量并无较大差别，并不要求全部大写； 只是考虑其含义的准确传递，常量多使用多单词组合的方式命名； 可以对名称本身就是全大写的特定常量使用全大写的名字； 1.4. 接口 在Go语⾔中，对于接口类型优先以单个单词命名； 对于拥有唯一⽅法或通过多个拥有唯一方法的接口组合而成的接口， Go语言的惯例是用“方法名+er”命名 2. 利用上下⽂环境，让最短的名字携带足够多的信息 在不影响可读性的前提下，兼顾一致性原则，尽可能地用短小的名字命名标识符。 // 不好的命名 func RuneCount(buffer []byte) int { runeCount := 0 for index := 0; index By YangXin Xu            updated 2023-10-03 15:28:35 "}}