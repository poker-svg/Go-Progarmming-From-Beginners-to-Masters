{"./":{"url":"./","title":"Introduction","keywords":"","body":"1. Introduction1. Introduction 这是我的《Go语言精进之路》的读书笔记的gitbook，会时不时更新。 By YangXin Xu            updated 2023-10-03 15:33:39 "},"第1条-了解Go语言的诞生和演进.html":{"url":"第1条-了解Go语言的诞生和演进.html","title":"第1条-了解Go语言的诞生和演进","keywords":"","body":"1. Go语言的诞生2. Go语言的早期团队和演进历程3. Go语言正式发布并开源1. Go语言的诞生 2009年9月20日，以下三位谷歌的大佬进行了一次有关设计一门新编程语言的讨论 Rob Pike：贝尔实验室早期成员，参与了Plan 9操作系统、C编译器和多种语言编译器的设计和实现，UTF-8的发明者之一 Robert Griesemer：Java的HotSpot虚拟机和Chrome浏览器的JavaScript V8引擎的设计者之一 Ken Thompson：图灵机得主，Unix之父，C语言的发明者之一 随后经过几次讨论和会议，Robert Griesemer 发出了一封题为 “prg lang discussion” 的电邮，对讨论进行了归纳总结：在C语言的基础上，修正明显的缺陷、删除被诟病的特性、增加缺失的功能： 使用 import 替代 include 去除宏 用一个源文件替代.h和.c文件，自动提取模块接口 语句像C语言一样，但需修正switch语句 表达式像C语言一样，但有些注意事项 基本上是强类型的，但需支持运行时类型 数组应该有边界检查 具备GC机制 支持接口 支持嵌套和匿名函数/闭包 一个简单的编译器 各种语言机制应该能产生可预测代码 golang仅应用于命名G语言官方网站，因为当时go.com域名被迪士尼公司占用 2. Go语言的早期团队和演进历程 2008年年初，Ken Thompson 实现了第一版Go编译器。此编译器先将Go代码转换为C代码，再由C编译器编译成二进制文件 2008年年中，同样在谷歌工作的 Ian Lance Taylor 为Go语言实现了一个GCC的前端，成为了Go语言的第二个编译器。随后他以第四位成员的身份正式加入Go语言开发团队 Russ Cox 是第五位加入Go语言开发团队的成员。他利用函数类型也可以拥有自己的方法这个特性巧妙设计出了http包的HandlerFunc类型 3. Go语言正式发布并开源 2009年10月30日，Rob Pike 在 Google Techtalk 上做了一次有关Go语言的演讲——The Go Programming Language ，首次将Go语言公之于众 2009年11月10日，G语言项目正式开源，开源后的Go语言吸引力全世界开发者的目光，越来越多贡献者开始为Go语言添砖加瓦 Go语言开源后，许多云计算领域的大厂和初创公司成为Go语言的早期接纳者，并产生了一系列杀手级项目：容器引擎Docker、云原生实施标准平台Kubernetes、服务网格Istio、区块链公链以太坊(Ethereum)、联盟链超级账本(Hyperledger Fabric)、分布式关系型数据库TiDB和CockroachDB、云原生监控系统Prometheus等 By YangXin Xu            updated 2023-10-03 13:00:54 "},"第2条-选择适当的Go语言版本.html":{"url":"第2条-选择适当的Go语言版本.html","title":"第2条-选择适当的Go语言版本","keywords":"","body":"1. Go语言的先祖2. Go语言的版本发布历史3. Go语言的版本选择建议1. Go语言的先祖 Go继承了诸多编程语言的特性： Go的基本语法参考了C语言，是”C家族语言“的一个分支 Go的声明语法、包概念则受到了Pascal、Modula、Oberon的启发 ⼀ 些并发的思想则来自受到Tony Hoare教授CSP理论影响的编程语言 2. Go语言的版本发布历史 (略) 3. Go语言的版本选择建议 Go开发团队一直建议大家使用最新的发布版 而开源社区则倾向于使用最新版本之前的哪个版本 By YangXin Xu            updated 2023-10-03 13:11:22 "},"第3条-理解Go语言的设计哲学.html":{"url":"第3条-理解Go语言的设计哲学.html","title":"第3条-理解Go语言的设计哲学","keywords":"","body":"1. 追求简单，少即是多2. 偏好组合，正交解耦3. 原生并发，轻量高效4. 面向工程，“自带电池”4.1. 语言4.2. 标准库4.3. 工具链1. 追求简单，少即是多 简单是一种伟大的美德，但我们需要更艰苦地努力才能实现它，并需要经过一个教育的过程才能去欣赏和领会它。但糟糕的是：复杂的东西似乎更有市场。 ——Edsger Dijkstra，图灵奖得主 Go 语言实际上是很复杂的，但只是让大家感觉很简单 ——Rob Pike，Go 语言之父 Go 的设计者们在语言设计之初就 拒绝走语言特性融合的道路，而选择了“做减法”，选择了“简单”，他们把复杂性留给了语言自身的设计和实现（Go 核心开发组自己），而将简单、易用和清晰留给了广大 Gopher： 简洁、常规的语法（不需要解析符号表），它仅有 25 个关键字； 内置垃圾收集，降低开发人员内存管理的心智负担； 没有头文件； 显式依赖（package）； 没有循环依赖（package）； 常量只是数字； 首字母大小写决定可见性； 任何类型都可以拥有方法（没有类）； 没有子类型继承（没有子类）； 没有算术转换； 接口是隐式的（无须 implements 声明）； 方法就是函数； 接口只是方法集合（没有数据）； 方法仅按名称匹配（不是按类型）； 没有构造函数或析构函数； n++和 n--是语句，而不是表达式； 没有++n 和--n； 赋值不是表达式； 在赋值和函数调用中定义的求值顺序（无“序列点”概念）； 没有指针算术； 内存总是初始化为零值； 没有类型注解语法（如 C++中的 const、static 等）； 没有模板/泛型； 没有异常（exception）； 内置字符串、切片（slice）、map 类型； 内置数组边界检查； 内置并发支持； Go 设计者推崇 “最小方式”思维 ：即一件事情仅有一种方式或数量尽可能少的方式去完成，这大大减少了开发人员在选择路径方式及理解他人所选路径方式上的心智负担 在 Go 演化进入关键阶段（走向 Go 2）的今天，有人向 Go 开发团队提出过这样一个问题：Go 后续演化的最大难点是什么？Go 开发团队的一名核心成员回答道：“最大的难点是如何继续保持 Go 语言的简单。” 2. 偏好组合，正交解耦 当我们有必要采用另一种方式处理数据时，我们应该有一些耦合程序的方式，就像花园⾥将浇⽔的软管通过预置的螺丝扣拧入另一段那样，这也是 Unix IO 采用的方式。 ——Douglas McIlroy，Unix 管道的发明者（1964） Go 语言本质上不属于经典 OO 语言范畴。Go 语言遵从的设计哲学是组合，通过组合将程序各个部分有机耦合在一起 在语言设计层面，Go 提供了正交的语法元素供后续组合使用，包括： Go 语言无类型体系（type hierarchy），类型之间是独⽴的，没有子类型的概念； 每个类型都可以有自己的方法集合，类型定义与方法实现是正交独立的； 接口（interface）与其实现之间隐式关联； 包（package）之间是相对独立的，没有子包的概念； Go 语言为我们呈现了这样一幅图景：一座座没有关联的“孤岛”，但每个岛内又都很精彩。现在摆在面前的工作就是以最适当的方式在这些孤岛之间建立关联（耦合），形成一个整体。Go采用了组合的方式，也是唯一的方式 Go 语言提供的最为直观的组合的语法元素是 类型嵌入（type embedding） 。通过类型嵌入，我们可以将已经实现的功能嵌入新类型中，以快速满足新类型的功能需求。我们也可以称之为 垂直组合 interface 是 Go 语言中真正的“魔法”，是 Go 语言的一个创新设计， 它只是方法集合，且与实现者之间的关系是隐式的，它让程序各个部 分之间的耦合降至最低，同时是连接程序各个部分的“纽带”。隐式的 interface 实现会不经意间自然而然地满足依赖抽象、里氏替换、接口隔离等设计原则。我们也可称之为 水平组合 综上： 组合原则的应用塑造了 Go 程序的骨架结构； 类型嵌入为类型提供垂直扩展能力； interface 是水平组合的关键，它好比程序肌体上 的“关节”，给予连接“关节”的两个部分各自“自由活动”的能力，而整体上又实现了某种功能； 3. 原生并发，轻量高效 并发是有关结构的，而并行是有关执行的。 ——Rob Pike（2012） Go 的设计者敏锐地把握了 CPU 向多核方向发展的这一趋势，在决定不再使用 C++而去创建一门新语言的时候，果断将 面向多核、原生内置并发支持 作为新语言的设计原则之一 Go 语言原生支持并发的设计哲学体现在以下几点： Go 语言采用 轻量级协程并发模型，使得 Go 应用在面向多核硬件时更具可扩展性 Go 放弃了传统的基于操作系统线程的并发模型，而采用了 用户层轻量级线程（Go 称其为 goroutine） Go 运行时默认每个 goroutine 分配的栈空间仅为 2KB。goroutine 调度的切换也不用陷入操作系统内核层完成，代价很低。因此，在一个 Go 程序中可以创建成千上万个并发的 goroutine。 goroutine 的调度全靠 Go 自己完成，实现 Go 程序内 goroutine 之间公平地竞争 CPU 资源的任务就落到了 Go 运行时头上。而将这些 goroutine 按照一定算法放到 CPU 上执行的程序就称为 goroutine调度器 Go 语言为开发者提供的支持并发的语法元素和机制： 执行单元：goroutine； 创建和销毁方式：go+函数调用；函数退出即 goroutine 退出； 并发 goroutine 的通信：通过语言内置的 channel 传递消息或实现同步，并通过 select 实现多路 channel 的并发控制； 并发原则对 Go 开发者在程序结构设计层面的影响 并发是有关结构的，它是一种将一个程序分解成多个小片段并且 每个小片段都可以独立执⾏的程序设计方法；并发程序的小片段之间一般存在通信联系并且通过通信相互协作； 并行是有关执行的，它表示同时进行一些计算任务； 并发程序的结构设计不要局限于在单核情况下处理能力的高低，而要以 在多核情况下充分提升多核利用率、获得性能的自然提升为最终目的 4. 面向工程，“自带电池” 软件工程指引着 Go 语言的设计。 ——Rob Pike（2012） 三位 Go 语言之父在设计 Go 语言时的初衷：面向真实世界中 Google 内部大规模软件开发存在的各种问题，为这些问题提供答案 在 Go 语言最初设计阶段就将 解决工程问题 作为 Go 的设计原则之一去考虑 Go 语法、工具链与标准库的设计，这也是 Go 与那些偏学院派、偏研 究性编程语言在设计思路上的一个重大差异 Go 设计者将所有工程问题浓缩为一个词：scale 。Go 的设计目标就是帮助开发者更容易、更高效地管理两类规模： 生产规模：用 Go 构建的软件系统的并发规模，比如这类系统并发关注点的数量、处理数据的量级、同时并发与之交互的服务的数 量等； 开发规模：包括开发团队的代码库的大小，参与开发、相互协作的工程师的人数等； 4.1. 语言 面向工程的语言设计细节要考量以下这些： 重新设计编译单元和目标文件格式，实现 Go 源码快速构建，将大工程的构建时间缩短到接近于动态语言的交互式解释的编译时间。 如果源文件导入了它不使用的包，则程序将无法编译。这既可以充分保证 Go 程序的依赖树是精确的，也可以保证在构建程序时不会编译额外的代码，从而最大限度地缩短编译时间。 去除包的循环依赖。循环依赖会在大规模的代码中引发问题，因为它们要求编译器同时处理更大的源文件集，这会减慢增量构建速度。 在处理依赖关系时，有时会通过允许一部分重复代码来避免引入较多依赖关系。比如：net 包具有其自己的整数到十进制转换实现，以避免依赖于较大且依赖性较强的格式化 io 包。 包路径是唯一的，而包名不必是唯一的。导入路径必须唯一标识要导入的包，而名称只是包的使用者对如何引用其内容的约定。包名不必是唯一的约定大大降低了开发人员给包起唯一名字的心 智负担。 故意不支持默认函数参数。因为在规模工程中，很多开发者利用默认函数参数机制向函数添加过多的参数以弥补函数 API 的设计缺陷，这会导致函数拥有太多的参数，降低清晰度和可读性。 首字母大小写定义标识符可见性，这是 Go 的一个创新。它让开发人员通过名称即可知晓其可见性，而无须回到标识符定义的位置查找并确定其可见性，这提升了开发人员阅读代码的效率。 在语义层面，相对于 C，Go 做了很多改动，提升了语言的健壮性，比如去除指针算术，去除隐式类型转换等。 内置垃圾收集。这对于大型工程项目来说，大大降低了程序员在 内存管理方面的负担，程序员使用 GC 感受到的好处超过了付出的成本，并且这些成本主要由语言实现者来承担。 内置并发⽀持，为网络软件带来了简单性，而简单又带来了健壮，这是大型工程软件开发所需要的。 增加类型别名，支持大规模代码库的重构。 4.2. 标准库 Go 被称为 “自带电池”（battery-included） 的编程语言 如果说⼀门编程语言“自带电池”，则说明这门语言标准库功能丰富，多数功能无须依赖第三方包或库，Go 语言恰是这类编程语言 4.3. 工具链 Go 语言提供了十分全面、贴心的编程语言官方工具链，涵盖了编译、编辑、依赖获取、 调试、测试、⽂档、性能剖析等的方方面面： 构建和运行：go build/go run 依赖包查看与获取：go list/go get/go mod xx 编辑辅助格式化：go fmt/gofmt 文档查看：go doc/godoc 单元测试/基准测试/测试覆盖率：go test 代码静态分析：go vet 性能剖析与跟踪结果查看：go tool pprof/go tool trace 升级到新 Go 版本 API 的辅助工具：go tool fix 报告 Go 语言 bug：go bug Go 构建了⼀个开放的工具链生态系统，它鼓励社区和开发人员为 Go 添加更多、更实用的工具，而更多、更实用的工具反过来又帮助 Go 更好地解决工程上的“规模化”问题，这是一个良性的生态循环。 By YangXin Xu            updated 2023-10-03 21:30:38 "},"第4条-使用Go语言原生编程思维来写Go代码.html":{"url":"第4条-使用Go语言原生编程思维来写Go代码.html","title":"第4条-使用Go语言原生编程思维来写Go代码","keywords":"","body":"1. 语言与思维2. 现实的投影2.1. C 语言版本2.2. Haskell 版本2.3. Go 语言版本3. Go 语言原生编程思维1. 语言与思维 在人类自然语言学界有⼀个很著名的假说——“萨丕尔-沃夫假说”，这个假说的内容是这样的：“语言影响或决定人类的思维方式。” 2. 现实的投影 埃拉托斯特尼素数筛算法的不同语言实现 2.1. C 语言版本 #include #define LIMIT 50 #define PRIMES 10 void sieve() { int c, i,j,numbers[LIMIT], primes[PRIMES]; for (i=0;i C 版本的素数筛程序是⼀个常规实现。它定义了两个数组 numbers 和 primes，“筛”的过程在 numbers 这个数组中进行（基于纯内存修改），非素数的数组元素被设置为-1，便于后续提取。 2.2. Haskell 版本 sieve [] = [] sieve (x:xs) = x : sieve (filter (\\a -> not $ a `mod` x == 0) xs) n = 100 main = print $ sieve [2..n] Haskell 版本采用了函数递归的思路，通过“filter 操作集合”，用谓词（过滤条件）\\a -> not $ a `mod` x == 0 筛除素数的倍数，将未筛除的数的集合作为参数传递归递给下去。 2.3. Go 语言版本 func Generate(ch chan Go 版本程序实现了⼀个并发素数筛，它采用的是 goroutine 的并发组合。程序从素数 2 开始，依次为每个素数建⽴⼀个 goroutine，用 于作为筛除该素数的倍数。 3. Go 语言原生编程思维 编程语言影响编程思维，每种编程语言都有属于自己的原生编程思维： C 语言相信程序员，提供指针和指针运算，让 C 程序员天马行空地自由发挥，接近提出的直接内存操作让 C 程序拥有很高的性能 C++支持多范式（命令式、OO、泛型），推荐使用最新代表现代语言发展特色的泛型等高级范式 Python 语言更是形成了 Pythonic 规则来指导 Python 程序员写出符合 Python 思维或惯用法的代码 By YangXin Xu            updated 2023-10-03 21:29:25 "},"第5条-使用得到工人且广泛使用的项目结构.html":{"url":"第5条-使用得到工人且广泛使用的项目结构.html","title":"第5条-使用得到工人且广泛使用的项目结构","keywords":"","body":"1. Go 项目的项目结构2. Go 语言典型项目结构2.1. Go 项目结构的最小标准布局2.2. 以构建二进制可执行文件为目的的 Go 项目结构2.3. 以只构建库为目的的 Go 项目结构2.4. 关于 internal 目录1. Go 项目的项目结构 截至 Go 项目 commit 1e3ffb0c （2019.5.14），Go 项目结构如下： $ tree -LF 1 ~/go/src/github.com/golang/go ./go ├── api/ ├── AUTHORS ├── CONTRIBUTING.md ├── CONTRIBUTORS ├── doc/ ├── favicon.ico ├── lib/ ├── LICENSE ├── misc/ ├── PATENTS ├── README.md ├── robots.txt ├── src/ └── test 2. Go 语言典型项目结构 2.1. Go 项目结构的最小标准布局 作为 Go 语言项目的技术负责人，Russ Cox 在一个开源项目的 issue 中给出了他关于 Go 项目结构的最小标准布局的想法。他认为 Go 项目的 最小标准布局 应该是这样的： // 在Go项目仓库根路径下 - go.mod - LICENSE - xx.go - yy.go ... // 或者 - go.mod - LICENSE - package1 - package1.go - package2 - package2.go ... 2.2. 以构建二进制可执行文件为目的的 Go 项目结构 2.3. 以只构建库为目的的 Go 项目结构 2.4. 关于 internal 目录 对于不想暴露给外部引用，仅限项目内部使用的包，在项目结构上可以通过internal包机制来实现： $tree -F ./chapter2/sources/GoLibProj GoLibProj ├── LICENSE ├── Makefile ├── README.md ├── go.mod ├── internal/ │ ├── ilib1/ │ └── ilib2/ ├── lib.go ├── lib1/ │ └── lib1.go └── lib2/ └── lib2.go 根据 Go internal 机制的作用原理，internal 目录下的 ilib1、 ilib2 可以被以 GoLibProj 目录为根目录的其他目录下的代码（⽐如 lib.go、lib1/lib1.go 等）所导入和使用，但是却不可以为 GoLibProj 目录 以外的代码所使用，从而实现选择性地暴露 API 包。 By YangXin Xu            updated 2023-10-03 21:29:37 "},"第6条-提交前使用gofmt格式化源码.html":{"url":"第6条-提交前使用gofmt格式化源码.html","title":"第6条-提交前使用gofmt格式化源码","keywords":"","body":"1. gofmt：Go 语言在解决规模化问题上的最佳实践2. 使用 gofmt2.1. 使用 gofmt -s 选项简化代码2.2. 使用 gofmt -r 执行代码“微重构”2.3. 使用 gofmt -l 按格式要求输出满足条件的文件列表3. 使用 goimports4. 将 gofmt/goimports 与 IDE 或编辑器⼯具集成1. gofmt：Go 语言在解决规模化问题上的最佳实践 gofmt 的代码风格不是某个人的最爱，而是所有人的最爱。 ——Rob Pike gofmt 先入为主地将一种统一的代码风格内置到 Go 语言之中，并将其与 Go 语言一起以一种“标准”的形式推广给所有 Go 开发者。 gofmt 代码风格已经成为 Go 开发者的共识，融入 Go 语言的开发文化当中，以至于多数 Go 开发者可能说不出 gofmt 代码风格是什么样的，因为代码会被 gofmt 自动变成那种风格，大家已经不再关心风格。 很多主流语言在效仿 Go 语言而推出自己的格式化工具，⽐如 Java formatter、Clang formatter、Dartfmt 等。 2. 使用 gofmt $ gofmt -help usage: gofmt [flags] [path ...] -cpuprofile string write cpu profile to this file -d display diffs instead of rewriting files -e report all errors (not just the first 10 on different lines) -l list files whose formatting differs from gofmt's -r string rewrite rule (e.g., 'a[b:len(a)] -> a[b:]') -s simplify code -w write result to (source) file instead of stdout gofmt 最⼤的特点是没有提供任何关于代码风格设置的命令行选项和参数，这样 Go 开发人员就无法通过设置命令行特定选项来定制自己喜好的风格。 2.1. 使用 gofmt -s 选项简化代码 通过 gofmt -s 可以将遗留代码中的非简化代码自动转换为简化写法，并且没有副作用，因此一般“-s”选项都会是 gofmt 执行的默认选项。 2.2. 使用 gofmt -r 执行代码“微重构” gofmt -r 'pattern -> replacement' [other flags] [path ...] gofmt 除了具有格式化代码的功能外，对代码重构也具有一定的支撑能力。我们可以通过-r 命令行选项对代码进行表达式级别的替换，以达到重构的目的。 2.3. 使用 gofmt -l 按格式要求输出满足条件的文件列表 $ gofmt -l $GOROOT/src $GOROOT/src/cmd/cgo/zdefaultcc.go $GOROOT/src/cmd/go/internal/cfg/zdefaultcc.go $GOROOT/src/cmd/go/internal/cfg/zosarch.go ... $GOROOT/src/go/build/zcgo.go gofmt 提供了-l 选项，可以按格式要求输出满足条件的文件列表。 3. 使用 goimports Go 编译器在编译源码时会对源码文件导入的包进行检查，对于源文件中没有使用但却导入了的包或使用了但没有导入的包，Go 编译器都会报错。遗憾的是，gofmt 工具无法自动增加或删除文件头部的包导入列表。为此，Go 核心团队的 Brad Fitzpatrick 实现了 goimports，该工具后来被移到官方仓库 golang.org/x/tools/cmd/goimports 下维护了。 安装 goimports： $go get golang.org/x/tools/cmd/goimports $ ./goimports -help usage: goimports [flags] [path ...] -cpuprofile string CPU profile output -d display diffs instead of rewriting files -e report all errors (not just the first 10 on different lines) -format-only if true, don't fix imports and only format. In this mode, goimports is effectively gofmt, with the addition that imports are grouped into sections. -l list files whose formatting differs from goimport's ... 4. 将 gofmt/goimports 与 IDE 或编辑器⼯具集成 (略) By YangXin Xu            updated 2023-10-03 21:27:46 "},"第7条-使用Go命名惯例对标识符进行命名.html":{"url":"第7条-使用Go命名惯例对标识符进行命名.html","title":"第7条-使用Go命名惯例对标识符进行命名","keywords":"","body":"1. 简单且一致1.1. 包1.2. 变量、类型、函数和方法1.3. 常量1.4. 接口2. 利用上下⽂环境，让最短的名字携带足够多的信息 计算机科学中只有两件难事：缓存失效和命名。 ——Phil Karlton，Netscape 架构师 Go 的设计哲学之一就是追求简单，它在命名上一样秉承着简单的总体原则。 但简单并不意味着一味地为标识符选择短小的名字，而是要选择那种可以在标识符所在上下文中保持其用途清晰明确的名字。 Go 及其标准库的实现是 Go 命名惯例形成的源头，因此如果要寻找良好 命名的示范，Go 标准库是一个不错的地方。 1. 简单且一致 1.1. 包 对于 Go 中的包，一般建议以小写形式的单个单词命名； 我们在给包命名时不要有是否与其他包重名的顾虑，因为在 Go 中，包名可以不唯一； Go 语言建议，包名应尽量与包导入路径的最后一个路径分段保持一致； 我们在给包命名的时候，不仅要考虑包自身的名字，还要兼顾该包导出的标识符（如变量、常量、类型、函数等）的命名； 1.2. 变量、类型、函数和方法 Go 语言官方要求标识符命名采用驼峰命名法：非公开的使用小驼峰，公开的使用大驼峰； 循环和条件变量多采用单个字母命名（具体见上⾯的统计数据）； 函数/方法的参数和返回值变量以单个单词或单个字母为主； 由于方法在调用时会绑定类型信息，因此方法的命名以单个单词为主； 函数多以多单词的复合词进行命名； 类型多以多单词的复合词进行命名。 变量名字中不要带有类型信息 保持简短命名变量含义上的⼀致性 1.3. 常量 但在 Go 语言中，常量在命名方式上与变量并无较大差别，并不要求全部大写； 只是考虑其含义的准确传递，常量多使用多单词组合的方式命名； 可以对名称本身就是全大写的特定常量使用全大写的名字； 1.4. 接口 在 Go 语言中，对于接口类型优先以单个单词命名； 对于拥有唯一⽅法或通过多个拥有唯一方法的接口组合而成的接口， Go 语言的惯例是用“方法名+er”命名 2. 利用上下⽂环境，让最短的名字携带足够多的信息 在不影响可读性的前提下，兼顾一致性原则，尽可能地用短小的名字命名标识符。 // 不好的命名 func RuneCount(buffer []byte) int { runeCount := 0 for index := 0; index By YangXin Xu            updated 2023-10-03 21:31:20 "},"第8条-使用一致的变量声明形式.html":{"url":"第8条-使用一致的变量声明形式.html","title":"第8条-使用一致的变量声明形式","keywords":"","body":"1. 包级变量的声明形式1.1. 声明并同时显式初始化1.2. 声明但延迟初始化1.3. 声明聚类与就近原则2. 局部变量的声明形式2.1. 延迟初始化的局部变量声明2.2. 声明且显式初始化的局部变量2.3. 尽量在分支控制处应用短变量声明形式3. 小结1. 包级变量的声明形式 包级变量只能使用带有 var 关键字的变量声明形式 1.1. 声明并同时显式初始化 此类包级变量在实践中多使用如下格式 var variableName = InitExpression 如果想要显式为包级变量指定类型，Go 语言官方更推荐下面的第二种方式： // 第一种 var a int32 = 17 var a = int32(17) 1.2. 声明但延迟初始化 对于声明时并不显式初始化的包级变量，我们使用最基本的声明形式： var a int 32 1.3. 声明聚类与就近原则 推荐将同一类的变量声明放在一个 var 块中；或者将延迟初始化的变量声明放在一个 var 块中 // $GOROOT/src/net/http/server.go var ( bufioReaderPool sync.Pool bufioWriter2kPool sync.Pool bufioWriter4kPool sync.Pool ) var copyBufPool = sync.Pool { New: func() interface{} { b := make([]byte, 32*1024) return &b }, } ... // $GOROOT/src/net/net.go var ( aLongTimeAgo = time.Unix(1, 0) noDeadline = time.Time{} noCancel = (chan struct{})(nil) ) var threadLimit chan struct{} ... 在实践中，是否应当将包级变量的声明全部集中于源文件头部呢？或者遵守 就近原则 ，尽可能在靠近第一次使用变量的位置声明该变量 如果一个包级变量仅在一处使用，则遵守就近原则；如果一个包级变量在包内部被多处使用，则放在源文件头部更好 2. 局部变量的声明形式 相比于包级变量，局部变量多了一种短变量声明形式。 2.1. 延迟初始化的局部变量声明 采用带有 var 关键字的声明形式 // $GOROOT/src/strings/replace.go func (r *byteReplacer) Replace(s string) string { var buf []byte // 延迟分配 for i := 0; i 2.2. 声明且显式初始化的局部变量 建议使用短变量声明形式 a := int32(17) f := float32(3.14) s := []byte(\"hello, gopher!\") 2.3. 尽量在分支控制处应用短变量声明形式 // $GOROOT/src/net/net.go func (v *Buffers) WriteTo(w io.Writer) (n int64, err error) { // 笔者注：在if循环控制语句中使用短变量声明形式 if wv, ok := w.(buffersWriter); ok { return wv.writeBuffers(v) } // 笔者注：在for条件控制语句中使用短变量声明形式 for _, b := range *v { nb, err := w.Write(b) n += int64(nb) if err != nil { v.consume(n) return n, err } } v.consume(n) return n, nil } 3. 小结 By YangXin Xu            updated 2023-10-03 21:31:42 "},"第9条-使用无类型常量简化代码.html":{"url":"第9条-使用无类型常量简化代码.html","title":"第9条-使用无类型常量简化代码","keywords":"","body":"1. Go常量溯源2. 有类型常量带来的烦恼3. 无类型常量消除烦恼，简化代码4. 小结1. Go常量溯源 早期C语言使用宏来指代字面值，即所谓 宏定义常量 #define MAX_LEN 0x12345678 #define CMCC_SERVICE_PHONE_NUMBER 10086 #define PI 3.1415926 #define WELCOME_TO_GO \"Hello, Gopher\" #define A_CHAR 'a' 宏定义的缺点： 仅是预编译阶段进行替换的字面值，继承了宏替换的复杂性和易错性 是类型不安全的 无法在调试时通过宏名字输出常量的值 C语言中的const修饰的标识符本质上仍是变量。因此编译器不能像对待真正的常量那样对其进行代码优化 Go语言中的const整合了 C语言中的宏定义常量 、const只读变量 、枚举常量 三种形式，并消除了每种形式的不足，使得Go常量成为 类型安全 且 对编译器优化友好的语法元素。 绝大多数情况下，Go常量在声明时并不显式指定类型，即所谓无类型常量： // $GOROOT/src/io/io.go const ( SeekStart = 0 SeekCurrent = 1 SeekEnd = 2 ) 2. 有类型常量带来的烦恼 Go是对类型安全要求十分严格的编程语言。即使两个类型拥有相同的底层类型，仍视作毫无关系的两个类型，无法进行 隐式转换 ： type myInt int func main() { var a int = 5 var b myInt = 6 fmt.Println(a + b) // 编译器会给出错误提⽰：invalid operation: // a + b (mismatched types int and myInt) fmt.Println(a + int(b)) // 输出: 11 } 因此有类型常量会给代码简化带来麻烦，这也是Go语言对类型安全严格要求的结果 3. 无类型常量消除烦恼，简化代码 Go语言的无类型常量拥有像字面值一样的特性：可以在参与变量赋值和计算过程时无需显式类型转换，从而达到简化代码的目的 const ( a = 5 pi = 3.1415926 s = \"Hello, Gopher\" c = 'a' b = false ) type myInt int type myFloat float32 type myString string func main() { var j myInt = a var f myFloat = pi var str myString = s var e float64 = a + pi fmt.Println(j) // 输出：5 fmt.Println(f) // 输出：3.1415926 fmt.Println(str) // 输出：Hello, Gopher fmt.Printf(\"%T, %v\\n\", e, e) // float64, 8.1415926 } 无类型常量并不是没有类型，它们也拥有自己的默认类型：⽆类型的布尔型 常量、整数常量、字符常量、浮点数常量、复数常量、字符串常量对 应的默认类型分别为bool、int、int32(rune)、float64、complex128和 string。 4. 小结 所有常量表达式的求值计算都可以在编译器而不是在运行期完成，这样既可以减少运行时间，也可以方便编译器进行编译优化，甚至可以筛选出部分运行时错误 By YangXin Xu            updated 2023-10-03 17:55:26 "},"第10条-使用iota实现枚举常量.html":{"url":"第10条-使用iota实现枚举常量.html","title":"第10条-使用iota实现枚举常量","keywords":"","body":" C家族中的主流编程语言都提供定义枚举常量的语法： // C语法 enum Weekday { SUNDAY, MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY }; int main() { enum Weekday d = SATURDAY; printf(\"%d\\n\", d); // 6 } 枚举的存在满足了以下两个现实需求： 有限数量标识符构成的集合 注重类型安全 然而Go语言并没有提供定义枚举常量的语法，它使用常量语法定义枚举常量： const ( Sunday = 0 Monday = 1 Tuesday = 2 Wednesday = 3 Thursday = 4 Friday = 5 Saturday = 6 ) Go的const语法还提供了“隐式重复上一个非空表达式”的机制： const ( Apple, Banana = 11, 22 Strawberry, Grape Pear, Watermelon ) // 等价于 const ( Apple, Banana = 11, 22 Strawberry, Grape = 11, 22 Pear, Watermelon = 11, 22 ) Go在此机制的基础上又提供了 iota ：iota是Go语言的一个预定义标识符，表示的是const声明块中每个常量所处位置在块中的偏移值 // $GOROOT/src/sync/mutex.go (go 1.12.7) const ( mutexLocked = 1 Go的枚举常量不限于整型值，也可以定义浮点型的枚举常量 const ( PI = 3.1415926 // π PI_2 = 3.1415926 / (2 * iota) // π/2 PI_4 // π/4 ) iota使得维护枚举常量列表十分容易 const ( _ = iota Blue Black Red Yellow ) 最后，我们可以使用有类型枚举常量来保证类型安全 // $GOROOT/src/time/time.go type Weekday int const ( Sunday Weekday = iota Monday Tuesday Wednesday Thursday Friday Saturday ) By YangXin Xu            updated 2023-10-03 18:40:09 "},"第11条-尽量定义零值可用的类型.html":{"url":"第11条-尽量定义零值可用的类型.html","title":"第11条-尽量定义零值可用的类型","keywords":"","body":"1. Go类型的零值2. 零值可用3. 小结 保持零值可用。 ——Go 谚语 1. Go类型的零值 在C99规范中，有一段是否对栈上局部变量进行自动清零初始化的描述： 未被显式初始化且具有自动存储持续时间的对象，其值是不确定的。 Go语言规范中刮愈变了默认值的描述： 当通过声明或调用new为变量分配存储空间，或者通过复合文字字面量或调用make创建新值，且不提供显式初始化时，Go会为变量或值提供默认值（即零值） 2. 零值可用 Go从诞生以来就一直拼成这尽量保持“零值可用”的的理念 例一： var zeroSlice []int zeroSlice = append(zeroSlice, 1) zeroSlice = append(zeroSlice, 2) zeroSlice = append(zeroSlice, 3) fmt.Println(zeroSlice) // 输出：[1 2 3] 并未显式初始化的切片zeroSlice初值为nil，但却可以直接对其进行append操作，而不会出现引用nil的错误 例二： // chapter3/sources/call_method_through_nil_pointer.go func main() { var p *net.TCPAddr fmt.Println(p) //输出： } // $GOROOT/src/net/tcpsock.go func (a *TCPAddr) String() string { if a == nil { return \"\" } ip := ipEmptyString(a.IP) if a.Zone != \"\" { return JoinHostPort(ip+\"%\"+a.Zone, itoa(a.Port)) } return JoinHostPort(ip, itoa(a.Port)) } 可以看到Go标准库在定义TCPAddr类型及其方法时充分考虑了零值可用的理念，使得通过值为nil的TCPAddr指针变量依然可以调用String()方法 3. 小结 Go语言“零值可用”的理念给内置类型、标准库的使用者带来很多便利。 不过Go并非所有类型都是零值可用的，并且零值可用也有一定的限制： var s []int s[0] = 12 // 报错！ s = append(s, 12) // 正确 var m map[string]int m[\"go\"] = 1 // 报错！ m1 := make(map[string]int) m1[\"go\"] = 1 // 正确 By YangXin Xu            updated 2023-10-03 19:13:25 "},"第12条-使用复合字面值作为初值构造器.html":{"url":"第12条-使用复合字面值作为初值构造器.html","title":"第12条-使用复合字面值作为初值构造器","keywords":"","body":"1. 结构体复合字面值2. 数组 / 切片复合字面值3. map复合字面值 Go提供的复合字面值（composite literal）语法可以作为复合类型变量的初值构造器。 var s myStruct s.name = \"tony\" s.age = 23 var a [5]int a[0] = 13 a[1] = 14 ... a[4] = 17 sl := make([]int, 5, 5) sl[0] = 23 sl[1] = 24 ... sl[4] = 27 m := make(map[int]string) m[1] = \"hello\" m[2] = \"gopher\" m[3] = \"!\" // 使用复合字面值进行简化 s := myStruct{\"tony\", 23} a := [5]int{13, 14, 15, 16, 17} sl := []int{23, 24, 25, 26, 27} m := map[int]string {1:\"hello\", 2:\"gopher\", 3:\"!\"} 1. 结构体复合字面值 Go推荐使用 field:value 的复合字面值形式对 struct 类型变量进行值构造。这种值构造方式可以降低 结构体类型使用者 与 结构体类型设计者 之间的耦合，这也是Go语言的惯用法 field:value 形式字面值中的字段可以以任意次序出现，未显式出现在字面值的结构体中的字段将采用其对应类型的零值 不允许将从其他包导入的结构体中的未导出字段作为复合字面值中的field，这会导致编译错误 2. 数组 / 切片复合字面值 数组 / 切片使用下标作为field，从而实现其高级构造形式： numbers := [256]int{'a': 8, 'b': 7, 'c': 4, 'd': 3, 'e': 2, 'y': 1, 'x': 5} // [10]float{-1, 0, 0, 0, -0.1, -0.1, 0, 0.1, 0, -1} fnumbers := [...]float{-1, 4: -0.1, -0.1, 7:0.1, 9: -1} // $GOROOT/src/sort/search_test.go var data = []int{0: -10, 1: -5, 2: 0, 3: 1, 4: 2, 5: 3, 6: 5, 7: 7, 8: 11, 9: 100, 10: 100, 11: 100, 12: 1000, 13: 10000} var sdata = []string{0: \"f\", 1: \"foo\", 2: \"foobar\", 3: \"x\"} 3. map复合字面值 由于map类型具有原生的 key:value 构造形式，因此使用复合字面值作为初值构造器就显得自然许多。 // $GOROOT/src/time/format.go var unitMap = map[string]int64{ \"ns\": int64(Nanosecond), \"us\": int64(Microsecond), \"µs\": int64(Microsecond), // U+00B5 = 微符号 \"μs\": int64(Microsecond), // U+03BC = 希腊字⺟μ \"ms\": int64(Millisecond), ... } // $GOROOT/src/net/http/server.go var stateName = map[ConnState]string{ StateNew: \"new\", StateActive: \"active\", StateIdle: \"idle\", StateHijacked: \"hijacked\", StateClosed: \"closed\", } By YangXin Xu            updated 2023-10-03 20:25:13 "},"第13条-了解切片实现原理并高效使用.html":{"url":"第13条-了解切片实现原理并高效使用.html","title":"第13条-了解切片实现原理并高效使用","keywords":"","body":"1. 切片究竟是什么2. 切片的高级特性：动态扩容3. 尽量使用cap参数创建切片 每当你花费大量时间使用某种特定工具时，深入了解它并了解如何高效使用它是很值得的 1. 切片究竟是什么 Go语言数组是一个 固定长度的 、容纳同构类型元素的 连续序列。因此Go数组类型具有两个属性： 元素类型和数组长度 ，只有两个属性都相同的数组类型才是等价的 Go数组都是 值语义 ，即一个数组变量表示的是整个数组。而不是像C语言一样，数组变量还可以被视作指向数组第一个元素的指针。 切片之于数组就像是文件描述符之于文件：数组更多是退居幕后充当底层容器的角色；而切片更多是走向台前充当 访问底层容器的窗口 的角色： 切片在Go运行时层面的内部表示： //$GOROOT/src/runtime/slice.go type slice struct { array unsafe.Pointer // 指向下层数组某元素的指针，该元素也是切⽚的起始元素 len int // 切⽚的⻓度，即切⽚中当前元素的个数 cap int // 切⽚的最⼤容量 } 切片的创建： 数组的切片化： 共享数组的多切片访问： 切片的reslicing： 无论切片描述的底层数组有多大，作为参数传递的切片带来的性能存好都是很小且恒定的 切片可以提供比指针更为强大的功能，比如 下标访问 、边界溢出校验 、动态扩容 等 2. 切片的高级特性：动态扩容 // chapter3/sources/slice_append.go var s []int // s被赋予零值nil s = append(s, 11) fmt.Println(len(s), cap(s)) //1 1 s = append(s, 12) fmt.Println(len(s), cap(s)) //2 2 s = append(s, 13) fmt.Println(len(s), cap(s)) //3 4 s = append(s, 14) fmt.Println(len(s), cap(s)) //4 4 s = append(s, 15) fmt.Println(len(s), cap(s)) //5 8 append会根据切片的需要，在当前底层数组容量无法满足的情况下，动态分配新数组，新数组长度会按一定算法扩展。 新数组建立后，会将原数组数据复制到新数组中，再让切片指向新的底层数组，最后将原数组GC掉。 因此：当切片触碰到底层数组的上界时，继续添加元素会令切片的底层数组不在是原来的底层数组，从而会出现 切片和底层数组的隐式解除绑定的现象 。 3. 尽量使用cap参数创建切片 基于上面的原理，在创建新切片时，将预估的切片容量数据一cap参数传递给make，可以减少内存分配和数据移动的次数，从而提高性能。 By YangXin Xu            updated 2023-10-03 21:21:52 "},"第14条-了解map实现原理并高效使用.html":{"url":"第14条-了解map实现原理并高效使用.html","title":"第14条-了解map实现原理并高效使用","keywords":"","body":"1. 什么是map2. map的基本操作3. map的内部实现3.1. 初始状态3.1.1. tophash区域3.1.2. key存储区域3.1.3. value存储区域3.2. map扩容3.3. map和并发4. 尽量使用cap参数创建map5. 小结1. 什么是map map对value的类型没有限制，但对key的类型有严格要求：key的类型应该杨哥定义了多为 “==” 和 “!=” 两个操作符的操作数是的行为 。 因此函数、map、切片不能作为map的key类型 map类型不支持零值可用。因此对处于零值状态的map变量会导致运行时panic： var m map[string]int // m = nil m[\"key\"] = 1 // panic: assignment to entry in nil map 创建map类型变量有两种方式： 使用复合字面值创建map类型变量 // $GOROOT/src/net/status.go var statusText = map[int]string{ StatusOK: \"OK\", StatusCreated: \"Created\", StatusAccepted: \"Accepted\", ... } 使用make创建map类型变量 // $GOROOT/src/net/client.go icookies = make(map[string][]*Cookie) // $GOROOT/src/net/h2_bundle.go http2commonLowerHeader = make(map[string]string, len(common)) map也是引用类型，将其作为参数传入不会有很大的性能损耗。 2. map的基本操作 (略) 注意：对map做多次遍历，遍历的元素次序并不相同。 3. map的内部实现 在编译阶段Go编译器会将语法层面的map操作重写成运行时对应的函数调用： // $GOROOT/src/cmd/compile/internal/gc/walk.go // $GOROOT/src/runtime/map.go m := make(map[keyType]valType, capacityhint) → m := runtime.makemap(maptype, capacityhint, m) v := m[\"key\"] → v := runtime.mapaccess1(maptype, m, \"key\") v, ok := m[\"key\"] → v, ok := runtime.mapaccess2(maptype, m, \"key\") m[\"key\"] = \"value\" → v := runtime.mapassign(maptype, m, \"key\") // v是⽤于后续存储value 的空间的地址 delete(m, \"key\") → runtime.mapdelete(maptype, m, \"key\") 下图是map类型在运行时层实现的示意图： 3.1. 初始状态 hmap 是map类型的header，可以理解为map类型的描述符，他存储了后序map类型操作所需的所有信息 count ：当前map中的元素个数；也是len的返回值； flags ：当前map所处的状态标志，目前定义了4个状态值——iterator 、oldIterator 、hashWriting 、sameSizeGrow B ：是bucket数量的以2为底的对数 noverflow ：overflow bucket 的大约数量 hash0 ：哈希函数的种子值 buckets ：指向bucket数组的指针 oldbuckets ：在map扩容阶段指向旧bucket数组的指针 nevacuate ：在map扩容阶段充当扩容进度计数器。所有下标小于nevacuate的bucket都已经完成了数据排空和迁移操作 extra ：可选字段 bucket（桶）是用来真正存储键值对数据的容器，每个bucket存储的是Hash值低bit位数值相同的元素，默认容量为 BUCKETSIZE （值为8）； 当桶满且map尚未达到扩容条件时，运行时会建立overflow bucket链表挂在对应的bucket尾部； 每个bucket由三部分组成：tophash 、key 、value 3.1.1. tophash区域 运行时map会通过哈希函数对key做哈希运算并获得一个哈希值 hashcode 。 其低位值作为索引用于选定bucket，高位值作为tag用于精切匹配 3.1.2. key存储区域 当我们声明一个map类型变量时，Go运行时就会为该变量对应的特定map类型生成一个 runtime.maptype 实例： // $GOROOT/src/runtime/type.go type maptype struct { typ _type key *_type elem *_type bucket *_type // 表⽰hash bucket的内部类型 keysize uint8 // key的⼤⼩ elemsize uint8 // elem的⼤⼩ bucketsize uint16 // bucket的⼤⼩ flags uint32 } maptype的存在让Go在所有map类型共享一套运行时map操作函数，从而减少了最终二进制文件空间的占用 3.1.3. value存储区域 Go运行时采用了将key和value分开存储的策略，而非采用kv紧邻存储方案。这带来了算法上的复杂性，但减少了因为内存对齐带来的内存浪费： 如果key或value的数据长度超过一定数值，那么运行时不会再bucket中直接存储数据，而是会存储key或value的指针 3.2. map扩容 map扩容的时机： “overflow bucket” 过多导致的扩容 ：运行时会新建一个和现有规模一样的bucket数组，然后在进行assign和delete操作时进行排空和迁移。即所谓重新分配 “count > LoadFactor(负载因子) * 2^B ” 导致的扩容 ：运行时会建立一个两倍于现有规模的新bucket数组，原bucket数组会挂在oldbuckets指针下，新bucket数组则会挂在buckets指针下。真正的排空和迁移工作也是在进行assign和delete操作时逐步进行的。 3.3. map和并发 map实例不是并发写安全的，不支持并发读写；如果对其进行并发读写，会产生运行时panic；但是map是可以并发读的 Go1.9中引入了支持并发安全的 sync.Map 类型 由于map会自动扩容，所以Go不允许获取map中value的地址 4. 尽量使用cap参数创建map 如果可能的话，我们最好对map使用规模做出粗略的估算，并使用cap参数对map实例进行初始化。 5. 小结 在日常使用map的场合要把握住下面几个要点： 不要依赖map的元素遍历顺序； map不是线程安全的，不支持并发写； 不要尝试获取map中元素（value）的地址； 尽量使用cap参数创建map，以提升map平均访问性能，减少频繁扩容带来的不必要损耗。 By YangXin Xu            updated 2023-10-04 00:38:42 "},"第15条-了解string实现原理并高效使用.html":{"url":"第15条-了解string实现原理并高效使用.html","title":"第15条-了解string实现原理并高效使用","keywords":"","body":"1. Go语言的字符串类型2. 字符串的内部表示3. 字符串的高效构造4. 字符串相关的高效转换C语言使用以‘\\0’结尾的字符类型数组来表示字符串，有如下缺点： 类型安全性差 字符串操作要时刻考虑‘\\0’ 字符串数据可变 获取字符串长度代价大——O(n) 未内置对非ASCII字符的处理 1. Go语言的字符串类型 在Go语言中，无论是 字符串常量、字符串变量、字符串字面量 ，其类型都被设置为 string 。具有以下特点： string类型的数据不可变 ：对string的底层容器仅能进行只读操作 零值可用 获取长度的时机复杂的是O(1)级别 支持通过 +/+= 操作符进行字符串连接 支持各种比较关系操作符 == 、!= 、>= 、> 、 对非ASCII字符提供原生支持：Go语言源文件默认采用Unicode字符集 原生支持多行字符串 2. 字符串的内部表示 Go string 在运行时表示为如下结构： // $GOROOT/src/runtime/string.go type stringStruct struct { str unsafe.Pointer len int } 在实例化string过程中，Go运行时会创建一个临时slice，供后续运行时层向其中写入数据使用。数据写入完毕后该slice会被回收 由上可知：直接将string类型作为参数传入不会有太多损耗，因为它代表一个描述符的窗口，而非底层容器数组 3. 字符串的高效构造 Go语言有许多构造字符串的方法： 使用fmt.Sprintf； 使用strings.Join； 使用strings.Builder； 使用bytes.Buffer； 它们的推荐使用场景如下： 在能预估出最终字符串长度的情况下，使用预初始化的strings.Builder连接构建字符串效率最高； strings.Join连接构建字符串的平均性能最稳定，如果输入的多个字符串是以[]string承载的，那么strings.Join也是不错的选择； 使用操作符连接的方式最直观、最自然，在编译器知晓欲连接的字符串个数的情况下，使用此种方式可以得到编译器的优化处理； fmt.Sprintf虽然效率不高，但也不是一无是处，如果是由多种不同类型变量来构建特定格式的字符串，那么这种方式还是最适合的； 4. 字符串相关的高效转换 Go语言在标准库中提供了strings和strconv包，可以辅助Gopher对string类型数据进行更多高级操作。 可以去自行查阅其说明文档 By YangXin Xu            updated 2023-10-04 10:52:00 "},"第16条-理解Go语言的包导入.html":{"url":"第16条-理解Go语言的包导入.html","title":"第16条-理解Go语言的包导入","keywords":"","body":"1. Go程序构建过程2. 究竟是路径名还是包名3. 包名冲突问题 Go语言使用包作为基本单元来组织源码，可以说一个Go程序就是由一些包连接在一起构建而成的 Go编译速度快的三个原因： Go要求每个源文件在开头处显式地列出所有依赖的包导入，这样编译器不必读取整个文件就可以确定它依赖的包列表 Go要求包之间不能存在循环依赖，这样一个包的依赖关系就是一张有向无环图。从而可以实现包的并行编译 已编译的Go包对应的目标文件中，不仅记录了本包的导出符号信息，还记录了其所依赖包的导出符号信息。 1. Go程序构建过程 一个非main包在编译和会对应生成一个.a文件（可真是做Go包的目标文件），此目标文件实际上是通过pack工具对.o文件打包后形成的 默认情况下，编译过程中.a文件生成在临时目录下；如果是构建可执行程序，.a文件会在构建可执行程序的链接阶段起使用 在使用第三方包的时候，在第三方包源码存在且对应的.a已安装的情况下。编译器链接的仍然是根据第三方包最新源码编译出的.a文件，而不是已经安装的.a文件 即所谓的使用第三方包，实际上是链接了以该最新包源码编译的、存放在临时目录下的包的.a文件而已 2. 究竟是路径名还是包名 编译器i想要找到依赖包的源码文件，就需要知道依赖包的源码路径。而 源码路径 = 基础搜索路径 + 包导入路径 基础搜索路径 是一个全局的设置，下面是其规则描述： 所有包（无论是标准库包还是第三方包）的源码基础搜索路径都包括$GOROOT/src 在上述基础搜索路径的基础上，不同版本的Go包含的其他基础搜索路径有不同： Go 1.11版本之前，包的源码基础搜索路径还包括$GOPATH/src Go 1.11〜Go 1.12版本，包的源码基础搜索路径有三种模式： gopath模式下（GO111MODULE=off）：$GOPATH/src module-aware模式下（GO111MODULE=on）： $GOPATH/pkg/mod auto模式下（GO111MODULE=auto）： 在$GOPATH/src路径下，与gopath模式相同； 在$GOPATH/src路径外且包含 go.mod，与module-aware模式相同； Go 1.13版本，包的源码基础搜索路径有两种模式： gopath模式下（GO111MODULE=off）：$GOPATH/src； module-aware模式下（GO111MODULE=on/auto）： $GOPATH/pkg/mod； 未来的Go版本将只有module-aware模式，即只在module缓存的目录下搜索包的源码 包导入路径 就是在源文件头部写入的路径名 下面是例子： // p1.go package p1 import ( \"fmt\" \"time\" \"github.com/bigwhite/effective-go-book\" \"golang.org/x/text\" \"a/b/c\" \"./e/f/g\" ) ... // 该空间对应的搜索路径集合包括 - $GOROOT/src/fmt/ - $GOROOT/src/time/ - $GOROOT/src/github.com/bigwhite/effective-go-book/ - $GOROOT/src/golang.org/x/text/ - $GOROOT/src/a/b/c/ - $GOPATH/src/github.com/bigwhite/effective-go-book/ - $GOPATH/src/golang.org/x/text/ - $GOPATH/src/a/b/c/ - $CWD/e/f/g 总结： 源文件头部的包导入语句import后面的部分就是一个路径，路径的最后一个分段并不是包名 但包导入路径的最后一段目录名最好与包名一致 如果不一致时，最好使用如下语法将包名显式放入包导入语句中： package main import ( mypkg2 \"github.com/bigwhite/effective-go-book/chapter3-demo1/pkg/pkg2\" ) 3. 包名冲突问题 当出现包名冲突时，使用显式指定包名来解决此问题 package main import ( pkg1 \"github.com/bigwhite/effective-go-book/chapter3-demo1/pkg/pkg1\" mypkg1 \"github.com/bigwhite/effective-go-book/chapter3-demo2/pkg/pkg1\" ) By YangXin Xu            updated 2023-10-04 15:43:49 "},"第17条-理解Go语言表达式的求值顺序.html":{"url":"第17条-理解Go语言表达式的求值顺序.html","title":"第17条-理解Go语言表达式的求值顺序","keywords":"","body":"1. 包级别变量声明语句中的表达式求值顺序2. 普通求值顺序3. 赋值语句的求值4. switch/select语句中的表达式求值4.1. switch-case语句中的表达式求值4.2. select-case语句中的表达式求值1. 包级别变量声明语句中的表达式求值顺序 在一个Go包内部，包级别变量声明语句的表达式求值顺序是由 初始化依赖规则 决定的： 在Go包中，包级别变量的初始化按照变量声明的先后顺序进行； 如果某个变量（如变量a）的初始化表达式中直接或间接依赖其他变量（如变量b），那么变量a的初始化顺序排在变量b后面； 未初始化的且不含有对应初始化表达式或初始化表达式不依赖任何未初始化变量的变量，我们称之为 “ready for initialization”变量 ； 包级别变量的初始化是逐步进行的，每一步就是按照变量声明顺序找到下一个“ready for initialization”变量并对其进行初始化的过程。反复重复这一步骤，直到没有“ready for initialization”变量为止； 位于同一包内但不同文件中的变量的声明顺序依赖编译器处理文件的顺序：先处理的文件中的变量的声明顺序先于后处理的文件中的所有变量； 2. 普通求值顺序 Go规定表达式操作数中的所有函数、方法以及channel操作安装从左到右的次序进行求值 3. 赋值语句的求值 Go语言规定，赋值语句求值分为两个阶段： 第一阶段，对于等号左边的下标表达式、指针解引用表达式和等号右边表达式中的操作数，按照普通求值规则从左到右进行求值； 第⼆阶段，按从左到右的顺序对变量进行赋值； 4. switch/select语句中的表达式求值 4.1. switch-case语句中的表达式求值 这类求值属于“惰性求值”的范畴 惰性求值：只在需要求值时才会对表达式进行求值，目的是让计算机少做事，从而降低程序的消耗 对于switch-case语句而言，首先进行求值的是switch后面的表达； 接下来将按照从上到下、从左到右的顺序对case语句中的表达式进行求值。如果某个表达式的结果与switch表达式结果一致，那么求值停止，后面未求值的case表达式将被忽略； 4.2. select-case语句中的表达式求值 Go语言中的select为我们提供了一种在多个channel间实现“多路复用”的机制，是编写Go并发程序最常用的并发原语之一 select执行开始时，首先所有case表达式都会被按出现的先后顺序求值一遍； 如果选择要执行的是一个从channel接收数据的case，那么该case等号左边的表达式在接收前才会被求值； By YangXin Xu            updated 2023-10-04 16:01:10 "},"第18条-理解Go语言代码块与作用域.html":{"url":"第18条-理解Go语言代码块与作用域.html","title":"第18条-理解Go语言代码块与作用域","keywords":"","body":"1. Go代码块与作用域简介1.1. 代码块1.2. 作用域2. if条件控制语句的代码块2.1. 单if型2.2. if{}else{}型2.3. if{}else if{}else{} 型3. 其它控制语句的代码块规则简介3.1. for语句的代码块3.2. switch-case语句的代码块3.3. select-case语句的代码块1. Go代码块与作用域简介 1.1. 代码块 Go语言中的代码块是包裹在一对大括号内部的声明和语句，且代码块支持嵌套； 代码块是代码执行流流转的基本单元，代码执行流总是从一个代码块跳到另一个代码块 显式代码块：由一对大括号包裹的代码块。比如函数的函数体、for循环的循环体、if语句的某个分支 隐式代码块： 宇宙代码块：所有Go源码都在该隐式代码块中 包代码块：每个包都有一个包代码块，其中放置着该包的所有Go源码 文件代码块：每个文件都有一个文件代码块，其中包含着该文件中的所有Go源码 每个if、for和switch语句均被视为位于其自己的隐式代码块中 switch和select语句中的每个子句都被视作一个隐式代码块 1.2. 作用域 Go标识符的作用域是基于代码块定义的，作用域规则描述了标识符在哪些代码块中是有效的： 预定义标识符（make、new、cap、len等）的作用域范围是宇宙块； 顶层声明的常量、类型、变量或函数（但不是方法）对应的标识符的作用域范围是包代码块； Go源文件中导入的包名称的作用域范围的作用域范围是文件代码块 方法接收器、函数参数或返回值变量对应的标识符的作用域范围是函数体 在函数内部声明的常量或变量对应的标识符的作用域范围始于声明处，止于所处块末尾 在函数内部声明的类型标识符的作用域范围始于声明处，止于所处块末尾 2. if条件控制语句的代码块 2.1. 单if型 单if型具有一个隐式代码块，和内部的一个显式代码块： if SimpleStmt; Expression { ... } // 等价转换如下 { // 隐式代码块开始 SimpleStmt if Expression { // 显式代码块开始 ... } // 显式代码块结束 } // 隐式代码块结束 显然在SimpleStmt中使短变量声明形式定义的变量可以在if语句的显示代码块中使用 2.2. if{}else{}型 if{}else{}型具有一个隐式代码块，和内部的两个显式代码块： if Simplestmt; Expression { ... } else { ... } // 等价转换如下 { // 隐式代码块开始 SimpleStmt if Expression { // 显式代码块1开始 ... // 显式代码块1结束 } else { // 显式代码块2开始 ... } // 显式代码块2结束 } // 隐式代码块结束 2.3. if{}else if{}else{} 型 if SimpleStmt1; Expression1 { ... } else if SimpleStmt2; Expression2 { ... } else { ... } // 等价转换如下 { // 隐式代码块1开始 SimpleStmt1 if Expression1 { // 显式代码块1开始 ... } else { // 显式代码块1结束；显式代码块2开始 { // 隐式代码块2开始 SimpleStmt2 if Expression2 { // 显式代码块3开始 ... } else { // 显式代码块3结束；显式代码块4开始 ... } // 显式代码块4结束 } // 隐式代码块2结束 } // 显式代码块2结束 } // 隐式代码块1结束 3. 其它控制语句的代码块规则简介 3.1. for语句的代码块 for InitStmt; Condition; PostStmt { ... } // 等价转换 { // 隐式代码块开始 InitStmt for Condition; PostStmt { // for显式代码块 ... } } // 隐式代码块结束 for IndentifierList := range Expression { ... } // 等价转换 { // 隐式代码块开始 IndentifierList := InitialValueList for IndentifierList = range Expression { // for的显式代码块 ... } } // 隐式代码块结束 3.2. switch-case语句的代码块 switch SimpleStmt; Expression { case ExpressionList1: ... case ExpressionList2: ... default: ... } // 等价转换 { // 隐式代码块1开始 SimpleStmt switch Expression { // 显式代码块1开始 case ExpressionList1: { // 隐式代码块2开始 ... } // 隐式代码块2结束 case ExpressionList2: { // 隐式代码块3开始 ... } // 隐式代码块3结束 default: { // 隐式代码块4开始 ... } // 隐式代码块4结束 } // 显式代码块1结束 } // 隐式代码块1结束 3.3. select-case语句的代码块 和switch-case无法在case子句中声明变量不同的是，select-case可以在case子句中通过短变量声明定义新变量 select { case SendStmt: ... case RecvStmt: ... default: ... } // 等价转换 select { // 显式代码块开始 case SendStmt: { // 隐式代码块1开始 ... } // 隐式代码块1结束 case RecvStmt: { // 隐式代码块2开始，如果RecvStmt声明了新变量，那么该变量也应包含在隐式代码块2中 ... } // 隐式代码块2结束 default: { // 隐式代码块3开始 ... } // 隐式代码块3结束 } // 显式代码块结束 By YangXin Xu            updated 2023-10-04 19:41:06 "},"第19条-了解Go语言控制语句惯用法及使用注意事项.html":{"url":"第19条-了解Go语言控制语句惯用法及使用注意事项.html","title":"第19条-了解Go语言控制语句惯用法及使用注意事项","keywords":"","body":"1. 使用if控制语句时应遵循“快乐路径”原则2. for range的避坑指南2.1. 小心迭代变量的使用2.2. 注意参与迭代的是range表达式的副本2.3. 其他range表达式类型的使用注意事项3. break跳到哪里去了4. 尽量用case表达式列表替代fallthroughGo语言的控制结构全面继承了C语言的语法，并进行了一些创新： 总体上继承了C语言的控制语句关键字和使用方式； 坚持“一件事情仅有一种做法”的设计理念，仅保留for这一种循环控制语句，去掉while、do-while语法； 为break和continue增加后接label的可选能力； switch的case语句执行完毕后，默认不会像C语言那样继续执行下一个case中的语句，除非显式使用fallthrough关键字； switch的case语句支持表达式列表； 增加type switch，让类型信息也可以作为分支选择的条件； 增加针对channel通信的switch-case语句——select-case； 1. 使用if控制语句时应遵循“快乐路径”原则 所谓“快乐路径”即成功逻辑的代码执行路径，这个原则要求： 当出现错误时，快速返回； 成功逻辑不要嵌入if-else语句中； “快乐路径”的执行逻辑在代码布局上始终靠左，这样读者可以一眼看到该函数的正常逻辑流程； “快乐路径”的返回值一般在函数最后一行； 2. for range的避坑指南 2.1. 小心迭代变量的使用 // chapter3/sources/control_structure_idiom_1.go ... func demo1() { var m = [...]int{1, 2, 3, 4, 5} for i, v := range m { go func() { time.Sleep(time.Second * 3) fmt.Println(i, v) }() } time.Sleep(time.Second * 10) } ... goroutine执行的闭包函数引用了它的外层包裹函数中的变量i , v 因此变量i，v在主goroutine和新goroutine之间实现了共享 三秒后，所有新routine都去访问外层的共享变量i，v $go run control_structure_idiom_1.go 4 5 4 5 4 5 4 5 4 5 // chapter3/sources/control_structure_idiom_1.go ... func demo2() { var m = [...]int{1, 2, 3, 4, 5} for i, v := range m { go func(i, v int) { time.Sleep(time.Second * 3) fmt.Println(i, v) }(i, v) } time.Sleep(time.Second * 10) } 此时新goroutine访问的都是值传递进来的对应副本了 $go run control_structure_idiom_1.go 0 1 1 2 2 3 3 4 4 5 2.2. 注意参与迭代的是range表达式的副本 // chapter3/sources/control_structure_idiom_2.go ... func arrayRangeExpression() { var a = [5]int{1, 2, 3, 4, 5} var r [5]int fmt.Println(\"arrayRangeExpression result:\") fmt.Println(\"a = \", a) for i, v := range a { if i == 0 { a[1] = 12 a[2] = 13 } r[i] = v } fmt.Println(\"r = \", r) fmt.Println(\"a = \", a) } 上述例子中的for-range循环的等价伪代码如下： for i, v := range a_copy{ // a_copy是a的⼀个值副本 if i == 0 { a[1] = 12 a[2] = 13 } r[i] = v } 所以在for-range中的对原数组的修改并不会在循环过程中同步 执行结果如下 a = [1 2 3 4 5] r = [1 2 3 4 5] a = [1 12 13 4 5] 但我们可以使用数组指针来实现同步： // chapter3/sources/control_structure_idiom_2.go ... func pointerToArrayRangeExpression() { var a = [5]int{1, 2, 3, 4, 5} var r [5]int fmt.Println(\"pointerToArrayRangeExpression result:\") fmt.Println(\"a = \", a) for i, v := range &a { if i == 0 { a[1] = 12 a[2] = 13 } r[i] = v } fmt.Println(\"r = \", r) fmt.Println(\"a = \", a) } 执行结果如下： pointerToArrayRangeExpression result: a = [1 2 3 4 5] r = [1 12 13 4 5] a = [1 12 13 4 5] 2.3. 其他range表达式类型的使用注意事项 对于range后面的其他表达式类型，比如string、map和channel，for range依旧会制作副本。 3. break跳到哪里去了 善用break [label] 4. 尽量用case表达式列表替代fallthrough switch n { case 1: fallthrough case 3: fallthrough case 5: fallthrough case 7: odd() case 2: fallthrough case 4: fallthrough case 6: fallthrough case 8: even() default: unknown() } 更好的方式： switch n { case 1, 3, 5, 7: odd() case 2, 4, 6, 8: even() default: unknown() } By YangXin Xu            updated 2023-10-04 20:12:07 "},"第20条-在init函数中检查包级变量的初始状态.html":{"url":"第20条-在init函数中检查包级变量的初始状态.html","title":"第20条-在init函数中检查包级变量的初始状态","keywords":"","body":"1. 认识init函数2. 程序初始化顺序3. 使用init函数检查包级变量的初始状态3.1. 重置包级变量值3.2. 对包级变量进行初始化，保证其后续可用3.3. init函数中的注册模式3.4. init函数中检查失败的方法 从程序逻辑结构角度来看，包是Go程序逻辑封装的基本单元 每个包都可以理解为一个 “自治”的、封装良好的、对外暴露有限接口的 基本单元 在Go包中分布着常量、包级变量、函数、类型、类型方法、接口等，我们想要保证包内部这些元素在被使用之前处于合理有效的初始状态。而我们一般通过包的init函数来完成这一工作 1. 认识init函数 init函数是一个无参、无返回值的函数，每个init函数在整个Go程序生命周期内仅会被执行一次； 如果一个包定义了init函数，Go运行时会负责在该包初始化时调用它的init函数； 但是我们不能在Go程序中显式调用init函数，否则会产生编译错误； 每个组成Go包的Go源文件中可以定义多个init函数，而初始化Go包时，Go运行时会按照一定的次序逐一调用该包的init函数 一般来说，先被传递给Go编译器的源文件的init函数会先被执行，同一个源文件中的多个init函数按声明顺序依次执行。但是：请不要依赖init函数的执行次序 2. 程序初始化顺序 init函数的执行顺序排在其所在包的包级变量之后 3. 使用init函数检查包级变量的初始状态 init函数就好比Go包真正投入使用之前的唯一“质检员”，负责对包内部以及暴露到外部的包级数据的初始状态进行检查。 3.1. 重置包级变量值 3.2. 对包级变量进行初始化，保证其后续可用 3.3. init函数中的注册模式 3.4. init函数中检查失败的方法 By YangXin Xu            updated 2023-10-04 21:26:26 "},"第21条-让自己习惯于函数是“一等公民”.html":{"url":"第21条-让自己习惯于函数是“一等公民”.html","title":"第21条-让自己习惯于函数是“一等公民”","keywords":"","body":"1. 什么是“一等公民”2. 函数作为“一等公民”的特殊运用2.1. 函数式编程2.1.1. 柯里化函数2.1.2. 函子2.1.3. 延续传递式 Go语言中没有那些典型的面向对象语言的语法 在Go语言中，函数是唯一一种基于特定输入、实现特定任务并可反馈任务执行结果的代码块 本质上，我们可以说Go语言就是一组函数的集合 函数在Go语言中属于“一等公民” Go语言的函数具有如下特点： 以func关键字开头 支持多返回值 支持具名返回值 支持递归调用 支持同类型的可变参数 支持defer，实现函数的优雅返回 1. 什么是“一等公民” Wiki发明人、C2站点作者Ward Cunningham对“一等公民”的诠释： 如果一门编程语言对某种语言元素的创建和使用没有限制， 我们可以像对待值一样对待这种语法元素，那么我们就称这种语法元素是这门编程语言的“一等公民”。拥有“一等公民”待遇的语法元素可以存储在变量中，可以作为参数传递给函数，可以在函数内部创建并可以作为返回值从函数返回。在动态类型语言中，语言运行时还支持对“一等公民”类型的检查。 我们来看看Go语言的函数是如何满足上述条件而成为“一等公民”的： 正常创建 // $GOROOT/src/fmt/print.go func newPrinter() *pp { p := ppFree.Get().(*pp) p.panicking = false p.erroring = false p.wrapErrs = false p.fmt.init(&p.buf) return p } 在函数内创建 // $GOROOT/src/runtime/print.go func hexdumpWords(p, end uintptr, mark func(uintptr) byte) { p1 := func(x uintptr) { var buf [2 * sys.PtrSize]byte for i := len(buf) - 1; i >= 0; i-- { if x&0xF >= 4 } gwrite(buf[:]) } ... } 作为类型 // $GOROOT/src/net/http/server.go type HandlerFunc func(ResponseWriter, *Request) // $GOROOT/src/sort/genzfunc.go type visitFunc func(ast.Node) ast.Visitor // codewalk: https://tip.golang.org/doc/codewalk/functions/ type action func(current score) (result score, turnIsOver bool) 存储到变量中 // $GOROOT/src/runtime/vdso_linux.go func vdsoParseSymbols(info *vdsoInfo, version int32) { .... apply := func(symIndex uint32, k vdsoSymbolKey) bool { sym := &info.symtab[symIndex] typ := _ELF_ST_TYPE(sym.st_info) bind := _ELF_ST_BIND(sym.st_info) ... *k.ptr = info.loadOffset + uintptr(sym.st_value) return true } ... } 作为参数传入函数 // $GOROOT/src/time/sleep.go func AfterFunc(d Duration, f func()) *Timer { t := &Timer{ r: runtimeTimer{ when: when(d), f: goFunc, arg: f, }, } startTimer(&t.r) return t } 作为返回值从函数返回 // $GOROOT/src/strings/strings.go func makeCutsetFunc(cutset string) func(rune) bool { if len(cutset) == 1 && cutset[0] = 0 } } 正如Ward Cunningham对“一等公民”的诠释，Go中的函数可以像普通整型值那样被创建和使用 。 2. 函数作为“一等公民”的特殊运用 首先，Go是类型安全的语言，不允许隐式类型转换： var a int = 5 var b int32 = 6 fmt.Println(a + b) // 违法操作: a + b (不匹配的类型int和int32) fmt.Println(a + int(b)) // 正确：输出11 同样的，函数也可以被显式类型转换： // chapter4/sources/function_as_first_class_citizen_2.go func greeting(w http.ResponseWriter, r *http.Request) { fmt.Fprintf(w, \"Welcome, Gopher!\\n\") } func main() { http.ListenAndServe(\":8080\", http.HandlerFunc(greeting)) } // $GOROOT/src/net/http/server.go func ListenAndServe(addr string, handler Handler) error { server := &Server{Addr: addr, Handler: handler} return server.ListenAndServe() } // $GOROOT/src/net/http/server.go type Handler interface { ServeHTTP(ResponseWriter, *Request) } 上述代码是最为常见的一个用Go构建Web Server的例子：当用户访问此服务器的8080端口时，会收到“Welcom Gopher!”的应答 首先函数 ListenAndServe 的参数包含一个名为 Handler 的接口，该接口需要仅有一个方法 ServeHTTP 但是我们的函数 greeting 虽然函数原型于接口相同，却没有绑定到某个类型上成为方法，从而隐式地实现此接口。也就是说，我们并不能将 greeting 视作 Handler 接口的一个实现 但是我们却将 greeting 显式类型转换为 http.HandlerFunc 类型。而由下可知，http.HandlerFunc 实现了 Handler 接口： // $GOROOT/src/net/http/server.go type HandlerFunc func(ResponseWriter, *Request) // ServeHTTP调⽤f(w, r) func (f HandlerFunc) ServeHTTP(w ResponseWriter, r *Request) { f(w, r) } 为什么 http.HandlerFunc(greeting) 这种显示类型转换可以通过编译呢？因为 HandlerFunc 的底层类型 与 greeting 的原型是一致的 本质上，上述代码和下面代码是同一原理： type MyInt int var x int = 5 y := MyInt(x) // MyInt的底层类型为int，类⽐ HandlerFunc的底层类型为 func(ResponseWriter, *Request) 2.1. 函数式编程 虽然Go语言不推崇函数式编程，但有时候局部应用函数式编程风格可以写出更优雅、更简洁、更易维护的代码 2.1.1. 柯里化函数 函数柯里化：把接收多个参数的函数变化为接受一个单一参数的函数，并返回接受余下参数和返回结果的新函数的技术。 // chapter4/sources/function_as_first_class_citizen_4.go package main import \"fmt\" func times(x, y int) int { return x * y } func partialTimes(x int) func(int) int { return func(y int) int { return times(x, y) } } func main() { timesTwo := partialTimes(2) timesThree := partialTimes(3) timesFour := partialTimes(4) fmt.Println(timesTwo(5)) fmt.Println(timesThree(5)) fmt.Println(timesFour(5)) } $ go run function_as_first_class_citizen_4.go 10 15 20 上述例子利用了函数的两点性质： 在函数中定义，通过返回值返回； 闭包：闭包实在函数内部定义的匿名函数，并且允许该匿名函数访问定义它的外部函数的作用域。本质上，闭包是将 函数内部 和 函数外部 连接起来的桥梁 2.1.2. 函子 函子需要满足以下两个条件： 函子本身是一个容器类型。例如：切片、map、channel 该容器类型需要实现一个方法，此方法接受一个函数类型参数，并在容器的每个元素上应用那个函数，最终得到一个新函子。但是原函子容器内部的元素值不受影响 // chapter4/sources/function_as_first_class_citizen_5.go type IntSliceFunctor interface { Fmap(fn func(int) int) IntSliceFunctor } type intSliceFunctorImpl struct { ints []int } func (isf intSliceFunctorImpl) Fmap(fn func(int) int) IntSliceFunctor { newInts := make([]int, len(isf.ints)) for i, elt := range isf.ints { retInt := fn(elt) newInts[i] = retInt } return intSliceFunctorImpl{ints: newInts} } func NewIntSliceFunctor(slice []int) IntSliceFunctor { return intSliceFunctorImpl{ints: slice} } func main() { // 原切⽚ intSlice := []int{1, 2, 3, 4} fmt.Printf(\"init a functor from int slice: %#v\\n\", intSlice) f := NewIntSliceFunctor(intSlice) fmt.Printf(\"original functor: %+v\\n\", f) mapperFunc1 := func(i int) int { return i + 10 } mapped1 := f.Fmap(mapperFunc1) fmt.Printf(\"mapped functor1: %+v\\n\", mapped1) mapperFunc2 := func(i int) int { return i * 3 } mapped2 := mapped1.Fmap(mapperFunc2) fmt.Printf(\"mapped functor2: %+v\\n\", mapped2) fmt.Printf(\"original functor: %+v\\n\", f) // 原函⼦没有改变 fmt.Printf(\"composite functor: %+v\\n\", f.Fmap(mapperFunc1).Fmap(mapperFunc2)) } $ go run function_as_first_class_citizen_5.go init a functor from int slice: []int{1, 2, 3, 4} original functor: {ints:[1 2 3 4]} mapped functor1: {ints:[11 12 13 14]} mapped functor2: {ints:[33 36 39 42]} original functor: {ints:[1 2 3 4]} composite functor: {ints:[33 36 39 42]} 2.1.3. 延续传递式 阶乘函数递归版： // chapter4/sources/function_as_first_class_citizen_6.go func factorial(n int) int { if n == 1 { return 1 } else { return n * factorial(n-1) } } func main() { fmt.Printf(\"%d\\n\", factorial(5)) } 函数式编程有一种被称为 延续传递式（Continuation-passing Style，CPS） 的编程风格可以充分运用函数作为“一等公民”的特质 阶乘函数CPS版 // chapter4/sources/function_as_first_class_citizen_9.go func factorial(n int, f func(int)) { if n == 1 { f(1) // 基本情况 } else { factorial(n-1, func(y int) { f(n * y) }) } } func main() { factorial(5, func(y int) { fmt.Printf(\"%d\\n\", y) }) } 执行过程如下： f1 = func(y int) { fmt.Printf(\"%v\\n\", y) factorial(5, f1) f2 = func(y int) {f1(5 * y)} factorial(4, f2) f3 = func(y int) {f2(4 * y)} factorial(3, f3) f4 = func(y int) {f3(3 * y)} factorial(2, f4) f5 = func(y int) {f4(2 * y)} factorial(1, f5) f5(1) => f5(1) = f4(2 * 1) = f3(3 * 2 * 1) = f2(4 * 3 * 2 * 1) = f1(5 * 4 * 3 * 2 * 1) = 120 CPS是一个反例，尽管作为“一等公民”的函数给Go带来了前的噶的表达能力，但是如果选择了不适合的风格或为了函数式而进行函数式编程，那么就会出现代码难以理解且执行效率不高的情况。 By YangXin Xu            updated 2023-10-04 22:55:26 "},"第22条-使用defer让函数更简洁、更健壮.html":{"url":"第22条-使用defer让函数更简洁、更健壮.html","title":"第22条-使用defer让函数更简洁、更健壮","keywords":"","body":"1. defer的运行机制2. defer的常见用法2.1. 拦截panic2.2. 修改函数的具名返回值2.3. 输出调试信息2.4. 还原变量旧值3. 关于defer的几个关键问题3.1. 明确哪些函数可以作为deferred函数3.2. 把握好defer关键字后表达式的求值时机3.3. 知晓defer带来的性能损耗考虑下面的代码： // chapter4/sources/deferred_func_1.go func writeToFile(fname string, data []byte, mu *sync.Mutex) error { mu.Lock() f, err := os.OpenFile(fname, os.O_RDWR, 0666) if err != nil { mu.Unlock() return err } _, err = f.Seek(0, 2) if err != nil { f.Close() mu.Unlock() return err } _, err = f.Write(data) if err != nil { f.Close() mu.Unlock() return err } err = f.Sync() if err != nil { f.Close() mu.Unlock() return err } err = f.Close() if err != nil { mu.Unlock() return err } mu.Unlock() return nil } 上面的代码代表了一种普遍的问题：由于函数的复杂控制逻辑，可能会存在多个退出后门，那么如果我们想要在退出函数前释放之前申请的一些资源，我们就需要在各处的退出点之前复制一遍代码。 显然这不仅增大了源代码体积，还降低了可读性 还容易遗漏，大大增加了开发人员的心智负担 即使妥善处理了，如果函数被某些panic打断，我们也无法从panic中恢复并释放资源 而这个问题就是Go语言引入defer的初衷 1. defer的运行机制 defer的运作离不开函数： 在Go中，只有在函数和方法内部才能使用defer； defer关键字后只能接函数或方法（即所谓deferred函数）； defer将deferred函数注册到所在goroutine的deferred函数栈中，所有deferred函数将在原函数退出前按LIFO顺序调度执行 改良后的版本： // chapter4/sources/deferred_func_2.go(这⾥仅列出writeToFile变更后的代码) func writeToFile(fname string, data []byte, mu *sync.Mutex) error { mu.Lock() defer mu.Unlock() f, err := os.OpenFile(fname, os.O_RDWR, 0666) if err != nil { return err } defer f.Close() _, err = f.Seek(0, 2) if err != nil { return err } _, err = f.Write(data) if err != nil { return err } return f.Sync() } 2. defer的常见用法 2.1. 拦截panic defer的运行机制决定了无论函数是执行到函数体末尾正常返回，还是在函数体中的某个错误处理分支显式调用return返回，抑或函数体内部出现panic，已经注册了的defered函数都会被调度执行 因此我们可以利用defer来拦截panic，并按需要对panic进行处理： // chapter4/sources/deferred_func_3.go func bar() { fmt.Println(\"raise a panic\") panic(-1) } func foo() { defer func() { if e := recover(); e != nil { fmt.Println(\"recovered from a panic\") } }() bar() } func main() { foo() fmt.Println(\"main exit normally\") } $ go run deferred_func_3.go raise a panic recovered from a panic main exit normally deferred函数虽然可以拦截绝大部分的panic，但无法拦截并恢复一些运行时之外的致命问题。比如下面代码中通过C代码制造的崩溃，defered函数便无能为力 // chapter4/sources/deferred_func_4.go package main //#include //void crash() { // int *q = NULL; // (*q) = 15000; // printf(\"%d\\n\", *q); //} import \"C\" import ( \"fmt\" ) func bar() { C.crash() } func foo() { defer func() { if e := recover(); e != nil { fmt.Println(\"recovered from a panic:\", e) } }() bar() } func main() { foo() fmt.Println(\"main exit normally\") } $ go run deferred_func_4.go SIGILL: illegal instruction PC=0x409a7f4 m=0 sigcode=1 goroutine 0 [idle]: runtime: unknown pc 0x409a7f4 ... 2.2. 修改函数的具名返回值 // chapter4/sources/deferred_func_5.go func foo(a, b int) (x, y int) { defer func() { x = x * 5 y = y * 10 }() x = a + 5 y = b + 6 return } func main() { x, y := foo(1, 2) fmt.Println(\"x=\", x, \"y=\", y) } $ go run deferred_func_5.go x= 30 y= 80 2.3. 输出调试信息 典型用法比如：在出入函数时打印留痕日志（一般在调试日志级别下）： func trace(s string) string { fmt.Println(\"entering:\", s) return s } func un(s string) { fmt.Println(\"leaving:\", s) } func a() { defer un(trace(\"a\")) fmt.Println(\"in a\") } func b() { defer un(trace(\"b\")) fmt.Println(\"in b\") a() } func main() { b() } entering: b in b entering: a in a leaving: a leaving: b 2.4. 还原变量旧值 // $GOROOT/src/syscall/fs_nacl.go func init() { oldFsinit := fsinit defer func() { fsinit = oldFsinit }() fsinit = func() {} Mkdir(\"/dev\", 0555) Mkdir(\"/tmp\", 0777) mkdev(\"/dev/null\", 0666, openNull) mkdev(\"/dev/random\", 0444, openRandom) mkdev(\"/dev/urandom\", 0444, openRandom) mkdev(\"/dev/zero\", 0666, openZero) chdirEnv() } 3. 关于defer的几个关键问题 3.1. 明确哪些函数可以作为deferred函数 对于自定义的函数或方法，defer都可以支持，但是返回值会被自动丢弃 关于内置函数：append、cap、 len、make、new等内置函数是不可以直接作为deferred函数的，而 close、copy、delete、print、recover等可以 3.2. 把握好defer关键字后表达式的求值时机 defer关键字后面的表达式是在将deferred函数注册到deferred函数栈的时候进行求值的。 // chapter4/sources/deferred_func_7.go func foo1() { for i := 0; i foo1 result: 3 2 1 0 foo2 result: 3 2 1 0 foo3 result: 4 4 4 4 3.3. 知晓defer带来的性能损耗 基准性能测试： // chapter4/sources/defer_perf_benchmark_1_test.go package defer_test import \"testing\" func sum(max int) int { total := 0 for i := 0; i // Go 1.12 $ go test -bench . defer_perf_benchmark_1_test.go goos: darwin goarch: amd64 BenchmarkFooWithDefer-8 34581608 31.6 ns/op BenchmarkFooWithoutDefer-8 248793603 4.83 ns/op PASS ok command-line-arguments 2.830s 由上可知，使用defer函数的执行时间是没有使用defer函数的7倍左右。 经过Go 1.13和1.14版本后，defer性能提升巨大，已经和不用defer的性能相差很小了 By YangXin Xu            updated 2023-10-05 18:22:30 "},"第23条-理解方法的本质以选择正确的receiver类型.html":{"url":"第23条-理解方法的本质以选择正确的receiver类型.html","title":"第23条-理解方法的本质以选择正确的receiver类型","keywords":"","body":"1. 方法的本质2. 选择正确的receiver类型3. 基于对Go方法本质的理解巧解难题4. 小结 Go方法的一般声明形式如下： func (receiver T / *T) MethodName(参数列表) (返回值列表) { // 方法体 } 方法名的首字母是否大写决定了该方法是不是导出方法 方法定义要与类型定义放在同一个包内。由此我们可以推出： 不能为原生类型（如int、float64、map等）添加方法，只能为自定义类型定义方法 同理，可以推出：不能横跨Go包为其他包内的自定义类型定义方法 每个方法只能有一个receiver参数，不支持多receiver参数列表或变长receiver参数 receiver参数的基类型本身不能是指针类型或接口类型 1. 方法的本质 所有方法都可以等价转换为如下的 方法原型 ，在Go语言中这种等价转换是编译器在编译和生成代码是自动完成的： type T struct { a int } func (t T) Get() int { return t.a } func (t *T) Set(a int) int { t.a = a return t.a } // ------------------------------------------------ func Get(t T) int { return t.a } func Set(t *T, a int) int { t.a = a return t.a } 同样的，我们也可以将某类型变量调用自己的方法等价转换为如下的 方法表达式 var t T t.Get() t.Set(1) // ------------------------------------------------ var t T T.Get(t) (*T).Set(&t, 1) Go方法的本质：一个以方法所绑定类型实例为第一个参数的普通函数 2. 选择正确的receiver类型 当receiver参数的类型为T时，选择值类型的receiver 当receiver参数的类型为*T时，选择指针类型的receiver T类型实例t调用receiver类型为*T的M2方法是没问题的，同样*T类型实例pt调用receiver类型为T的M1方法也是可以的 选择receiver的初步结论： 如果要对类型实例进行修改，那么为receiver选择*T类型 如果没有对类型实例修改的需求，那么为receiver选择T类型或*T 类型均可；但考虑到Go方法调用时，receiver是以值复制的形式传入方法中的，如果类型的size较大，以值形式传入会导致较大损耗，这时选择*T作为receiver类型会更好些 3. 基于对Go方法本质的理解巧解难题 // chapter4/sources/method_nature_3.go type field struct { name string } func (p *field) print() { fmt.Println(p.name) } func main() { data1 := []*field{ {\"one\"}, {\"two\"}, {\"three\"} } for _, v := range data1 { go v.print() } data2 := []field{ {\"four\"}, {\"five\"}, {\"six\"} } for _, v := range data1 { go v.print() } time.Sleep(3 * time.Second) } $ go run method_nature_3.go one two three six six six 迭代data1时，由于data1中的元素类型是field指针（*field），因此赋值后v就是元素地址，每次调用print时传入的参数（v）实际上也是各个field元素的地址 迭代data2时，由于data2中的元素类型是field（非指针），需要将其取地址后再传入。这样每次传入的\\&v实际上是变量v的地址， 而不是切片data2中各元素的地址 修改后的版本： // chapter4/sources/method_nature_5.go ... type field struct { name string } func (p field) print() { fmt.Println(p.name) } ... 4. 小结 Go方法的本质：一个以方法所绑定类型实例为第一个参数的普通函数。 Go语法糖使得我们在通过类型实例调用类型方法时无须考虑实例类型与receiver参数类型是否一致，编译器会为我们做自动转换。 在选择receiver参数类型时要看是否要对类型实例进行修改。如有修改需求，则选择*T；如无修改需求，T类型receiver传值的性能损耗也是考量因素之一。 By YangXin Xu            updated 2023-10-06 09:25:29 "},"第24条-方法集合决定接口实现.html":{"url":"第24条-方法集合决定接口实现.html","title":"第24条-方法集合决定接口实现","keywords":"","body":"1. 方法集合2. 类型嵌入与方法集合2.1. 在接口类型中嵌入接口类型2.2. 在结构体类型在嵌入接口类型2.3. 在结构体类型中嵌入结构体类型3. defined类型的方法集合4. 类型别名的方法集合1. 方法集合 方法集合决定接口：自定义类型与接口之间的实现关系是松耦合的：如果某个自定义类型T的方法集合是某个接口类型的方法集合的超集，那么就说类型T实现了该接口，并且类型T的变量可以被赋值给该接口类型的变量； 对于非接口类型的自定义类型T，其方法集合由所有receiver为T类型的方法组成； 而类型*T的方法集合则包含所有receiver为T和*T类型的方法； 2. 类型嵌入与方法集合 2.1. 在接口类型中嵌入接口类型 通过在接口类型中嵌入其他接口类型可以实现接口的组合，这也是Go语言中基于已有接口类型构建新接口类型的惯用法： // $GOROOT/src/io/io.go type Reader interface { Read(p []byte) (n int, err error) } type Writer interface { Write(p []byte) (n int, err error) } type Closer interface { Close() error } // 以上为三个基本接口类型 // 下⾯的接口类型是通过嵌入上⾯的基本接口类型形成的 type ReadWriter interface { Reader Writer } type ReadCloser interface { Reader Closer } type WriteCloser interface { Writer Closer } type ReadWriteCloser interface { Reader Writer Closer } 通过嵌入其他接口类型而创建的新接口类型的方法集合包含了被嵌入接口类型的方法集合 在Go 1.14之前的版本中这种方式有一个约束，那就是被嵌入的接口类型的方法集合不能有交集，同时被嵌入的接口类型的方法集合中的方法不能与新接口中其他方法同名 2.2. 在结构体类型在嵌入接口类型 在结构体类型中嵌入接口类型后，该结构体类型的方法集合中将包含被嵌入接口类型的方法集合： // chapter4/sources/method_set_5.go type Interface interface { M1() M2() } type T struct { Interface } func (T) M3() {} func main() { DumpMethodSet((*Interface)(nil)) var t T var pt *T DumpMethodSet(&t) DumpMethodSet(&pt) } $ go run method_set_5.go method_set_utils.go main.Interface's method set: - M1 - M2 main.T's method set: - M1 - M2 - M3 *main.T's method set: - M1 - M2 - M3 Go选择方法的次序： 优先选择结构体自身实现的方法； 如果结构体自身并未实现，那么将查找结构体中的嵌入接口类型的方法集合中是否有该方法，如果有，则 提升（promoted） 为结构体的方法； 如果结构体嵌入了多个接口类型且这些接口类型的方法集合存在交集，那么Go编译器将报错，除非结构体自己实现了交集中的所有方法； 2.3. 在结构体类型中嵌入结构体类型 在结构体类型中嵌入结构体类型为Gopher提供了一种实现“继承”的手段，外部的结构体类型T可以“继承”嵌入的结构体类型的所有方法的实现，并且无论是T类型的变量实例还是*T类型变量实例，都可以调用所有“继承”的方法； 假设有如下的“继承”关系： type T1 struct{} func (T1) T1M1() { println(\"T1's M1\") } func (T1) T1M2() { println(\"T1's M2\") } func (*T1) PT1M3() { println(\"PT1's M3\") } type T2 struct{} func (T2) T2M1() { println(\"T2's M1\") } func (T2) T2M2() { println(\"T2's M2\") } func (*T2) PT2M3() { println(\"PT2's M3\") } type T struct { T1 *T2 } T类型的方法集合 = T1的方法集合 + *T2的方法集合； *T类型的方法集合 = *T1的方法集合 + *T2的方法集合。 3. defined类型的方法集合 Go语言支持基于已有的类型创建新类型： type MyInterface I type Mystruct T 已有的类型被称为 underlying 类型 ，而新类型被称为 defined 类型 。 基于接口类型创建的defined类型与原接口类型的方法集合是一致的。 而基于自定义非接口类型创建的defined类型则并没有“继承”原类型的方法集合，新的defined类型的方法集合是空的， 也就是说，即便原类型实现了某些接口，基于其创建的defined类型也没有“继承”这一隐式关联。新defined类型要想实现那些接口，仍需重新实现接口的所有方法。 4. 类型别名的方法集合 Go 1.9版本引入了类型别名，支持为已有类型定义别名： type byte = uint8 type rune = int32 类型别名与原类型拥有完全相同的方法集合，无论原类型是接口类型还是非接口类型。 By YangXin Xu            updated 2023-10-05 20:08:18 "},"第25条-了解变长参数函数的妙用.html":{"url":"第25条-了解变长参数函数的妙用.html","title":"第25条-了解变长参数函数的妙用","keywords":"","body":"1. 什么是变长参数函数2. 模拟函数重载3. 模拟实现函数的可选参数与默认参数4. 实现功能选项模式1. 什么是变长参数函数 变长参数函数：就是指调用时可以接受零个、一个或多个实际参数的函数 这种接受 “…T” 类型形式参数的函数就被称为变长参数函数 变长参数函数的 “…T” 类型形式参数在函数体内呈现为[]T类型的变量，它可匹配和接受的实参类型有两种： 多个T类型变量 t…（t为[]T类型变量） 两者不可混用 虽然string类型变量可以直接赋值给interface{}类型变量，但是[]string类型变量并不能直接赋值给[]interface{}类型变量 2. 模拟函数重载 函数重载：同一个作用于下存在名字相同但原型不同的若干函数。 Go语言不允许函数重载，原因如下： 其他语言的经验告诉我们，使用具有相同名称但函数签名不同的多种方法有时会很有用，但在实践中也可能会造成混淆和脆弱性。在Go的类型系统中，仅按名称进行匹配并要求类型一致是一个主要的简化决策。 但是我们可以使用变长参数函数来模拟重载函数： // chapter4/sources/variadic_function_5.go func concat(sep string, args ...interface{}) string { var result string for i, v := range args { if i != 0 { result += sep } switch v.(type) { case int, int8, int16, int32, int64, uint, uint8, uint16, uint32, uint64: result += fmt.Sprintf(\"%d\", v) case string: result += fmt.Sprintf(\"%s\", v) case []int: ints := v.([]int) for i, v := range ints { if i != 0 { result += sep } result += fmt.Sprintf(\"%d\", v) } case []string: strs := v.([]string) result += strings.Join(strs, sep) default: fmt.Printf(\"the argument type [%T] is not supported\", v) return \"\" } } return result } func main() { println(concat(\"-\", 1, 2)) println(concat(\"-\", \"hello\", \"gopher\")) println(concat(\"-\", \"hello\", 1, uint32(2), []int{11, 12, 13}, 17, []string{\"robot\", \"ai\", \"ml\"}, \"hacker\", 33)) } $ go run variadic_function_5.go 1-2 hello-gopher hello-1-2-11-12-13-17-robot-ai-ml-hacker-33 3. 模拟实现函数的可选参数与默认参数 如果参数在传入时有隐式要求的固定顺序（这点由调用者保证），我们还可以利用变长参数函数模拟实现函数的可选参数和默认参数。 // chapter4/sources/variadic_function_6.go type record struct { name string gender string age uint16 city string country string } func enroll(args ...interface{}) (*record, error) { if len(args) > 5 || len(args) 4. 实现功能选项模式 (略) By YangXin Xu            updated 2023-10-05 20:26:56 "},"第26条-了解接口类型变量的内部表示.html":{"url":"第26条-了解接口类型变量的内部表示.html","title":"第26条-了解接口类型变量的内部表示","keywords":"","body":"1. 接口类型变量的内部表示2. 输出接口类型变量内部表示的详细信息3. 接口类型的装箱原理 如果要从Go语言中挑选出一个语言特性放入其他语言，我会选择接口。 ——Russ Cos，Go核心团队技术负责人 接口时Go这本静态类型语言中唯一“动静兼备”的语言特性。 接口的静态特性： 接口类型变量具有静态类型。 支持在编译阶段的类型检查。 接口的动态特性： 接口类型变量兼具动态类型，即在运行时存储在接口类型变量中的值的真实类型。 接口类型变量在程序运行时可以被赋值为不同的动态类型变量，从而支持运行时多态。 1. 接口类型变量的内部表示 我们可以在 $GOROOT/src/runtime/runtime2.go 中找到接口类型变量在运行时的表示： // $GOROOT/src/runtime/runtime2.go type iface struct { tab *itab // 存储接口本身信息以及动态类型所实现的方法的信息 data unsafe.Pointer } type eface struct { _type *_type // 指向该接口类型变量的动态类型信息 data unsafe.Pointer } // $GOROOT/src/runtime/type.go type _type struct { size uintptr ptrdata uintptr hash uint32 tflag tflag align uint8 fieldalign uint8 kind uint8 alg *typeAlg gcdata *byte str nameOff ptrToThis typeOff } // $GOROOT/src/runtime/runtime2.go type itab struct { inter *interfacetype // 该接口类型自身的信息 _type *_type // 该接口类型变量的动态类型的信息 hash uint32 _ [4]byte fun [1]uintptr // 动态类型已实现的接口方法的调用地址数组 } // $GOROOT/src/runtime/type.go type interfacetype struct { typ _type // 类型信息 pkgpath name // 包路径名 mhdr []imethod // 接口方法集合切片 } 在运行时层面，接口类型变量有两种内部表示——eface和iface eface：用于表示没有方法的空接口（empty interface）类型变量， 即interface{}类型的变量。 iface：用于表示其余拥有方法的接口（interface）类型变量。 例子： type T struct { n int s string } func main() { var t = T { n: 17, s: \"hello, interface\", } var ei interface{} = t // Go运⾏时使⽤eface结构表⽰ei } type T struct { n int s string } func (T) M1() {} func (T) M2() {} type NonEmptyInterface interface { M1() M2() } func main() { var t = T{ n: 18, s: \"hello, interface\", } var i NonEmptyInterface = t } 2. 输出接口类型变量内部表示的详细信息 (略) 3. 接口类型的装箱原理 装箱：是编程语言领域的一个基础概念，一般是指把值类型转换成引用类型。 在Go语言中，将任意类型赋值给一个接口类型变量都是装箱操作。 因此接口类型的装箱实则是创建一个 eface 或 iface 的过程。 例子： // chapter5/sources/interface-internal-4.go type T struct { n int s string } func (T) M1() {} func (T) M2() {} type NonEmptyInterface interface { M1() M2() } func main() { var t = T{ n: 17, s: \"hello, interface\", } var ei interface{} ei = t var i NonEmptyInterface i = t fmt.Println(ei) fmt.Println(i) } 对应汇编代码如下： $go tool compile -S interface-internal-4.go > interface\u0002internal-4.s // interface-internal-4.s // 对应ei = t一⾏的汇编如下 ... 0x00b6 00182 (interface-internal-4.go:24) PCDATA $0, $1 0x00b6 00182 (interface-internal-4.go:24) PCDATA $1, $1 0x00b6 00182 (interface-internal-4.go:24) LEAQ \"\"..autotmp_15+408(SP), AX 0x00be 00190 (interface-internal-4.go:24) PCDATA $0, $0 0x00be 00190 (interface-internal-4.go:24) MOVQ AX, 8(SP) 0x00c3 00195 (interface-internal-4.go:24) CALL runtime.convT2E(SB) ... // 对应i = t一⾏的汇编如下 0x0128 00296 (interface-internal-4.go:27) PCDATA $0, $1 0x0128 00296 (interface-internal-4.go:27) PCDATA $1, $4 0x0128 00296 (interface-internal-4.go:27) LEAQ \"\"..autotmp_15+408(SP), AX 0x0130 00304 (interface-internal-4.go:27) PCDATA $0, $0 0x0130 00304 (interface-internal-4.go:27) MOVQ AX, 8(SP) 0x0135 00309 (interface-internal-4.go:27) CALL runtime.convT2I(SB) ... 汇编代码中有 convT2E 和 convT2I 两个runtime包的函数，其源代码如下： // $GOROOT/src/runtime/iface.go func convT2E(t *_type, elem unsafe.Pointer) (e eface) { if raceenabled { raceReadObjectPC(t, elem, getcallerpc(), funcPC(convT2E)) } if msanenabled { msanread(elem, t.size) } x := mallocgc(t.size, t, true) typedmemmove(t, x, elem) e._type = t e.data = x return } func convT2I(tab *itab, elem unsafe.Pointer) (i iface) { t := tab._type if raceenabled { raceReadObjectPC(t, elem, getcallerpc(), funcPC(convT2I)) } if msanenabled { msanread(elem, t.size) } x := mallocgc(t.size, t, true) typedmemmove(t, x, elem) i.tab = tab i.data = x return } convT2E 用于将任意类型转换为一个eface convT2I 用于将任意类型转换为一个iface By YangXin Xu            updated 2023-10-05 21:14:55 "},"第27条-尽量定义小接口.html":{"url":"第27条-尽量定义小接口.html","title":"第27条-尽量定义小接口","keywords":"","body":"1. Go推荐定义小接口2. 小接口的优势3. 定义小接口可以遵循的一些点 接口越大，抽象程度越低。 ——Rob Pike，Go语言之父 1. Go推荐定义小接口 接口就是将对象的行为进行抽象而形成的契约。 契约有繁有简， Go选择了去繁就简，这主要体现在以下两点上： 契约的自动遵守：Go语言中接口与其实现者之间的关系是隐式的，实现者仅需实现接口方法集中的全部方法，便自动遵守了契约，实现了该接口。 小契约：契约繁了便束缚了手脚，降低了灵活性，抑制了表现力。 下图示对Go标准项目（Go 1.13版本）、Docker项目（Docker 19.03版本）、Kubernetes项目（Kubernetes 1.17版本）中所定义接口的方法数的统计图，以及接口方法数量占比的柱状图： 2. 小接口的优势 接口越小，抽象程度越高，被接纳度越高 易于实现和测试 契约职责单一，易于复用组合 3. 定义小接口可以遵循的一些点 抽象出接口：初期不要在意接口大小 将大接口拆分成小接口：一段时间后，我们就会发现大接口会呈现出一种按业务逻辑自然分组的状态，便可以进行拆分 接口的单一契约职责 By YangXin Xu            updated 2023-10-05 21:25:37 "},"第28条-尽量避免使用空接口作为函数参数类型.html":{"url":"第28条-尽量避免使用空接口作为函数参数类型.html","title":"第28条-尽量避免使用空接口作为函数参数类型","keywords":"","body":" 空接口不提供任何信息。 ——Rob Pike，Go语言之父 Go编译器通过解析该接口定义得到接口的名字信息及方法信息， 在为此接口类型参数赋值时，编译器就会根据这些信息对实参进行检查； 如果参数类型为空接口interface{}，会发生什么呢？ 由于 “空接口不提供任何信息” （给编译器），那这意味着你没有为编译器提供关于传入实参数据的任何信息，从而你会绕过 静态类型语言类型安全检查的保护屏障 。导致一些问题被延迟到运行时才会出现 因此，建议广大Gopher尽可能抽象出带有⼀定行为契约的接口， 并将其作为函数参数类型，尽量不要使用可以逃过编译器类型安全检查的空接口类型。 By YangXin Xu            updated 2023-10-05 21:33:20 "},"第29条-使用接口作为程序水平组合的连接点.html":{"url":"第29条-使用接口作为程序水平组合的连接点.html","title":"第29条-使用接口作为程序水平组合的连接点","keywords":"","body":"1. 一切皆组合2. 垂直组合回顾3. 以接口为连接点的水平组合3.1. 基本形式3.2. 包裹函数3.3. 适配器函数类型3.4. 中间件 如果说C++和Java是关于类型层次结构和类型分类的语言，那么Go则是关于组合的语言。 ——Rob Pike，Go语言之父 “偏好组合，正交解耦” 是Go语言的重要设计哲学之一。如果说 “追求简单” 聚焦的是为Go程序提供各种小而精的零件，那么组合关注的就是如何将这些零件关联到一起，搭建出程序的静态骨架。 1. 一切皆组合 在语言设计层面，Go提供了诸多正交的语法元素供后续组合使用，包括： Go语言无类型体系（type hierarchy），类型定义正交独立； 方法和类型是正交的，每种类型都可以拥有自己的方法集合； 接口与其实现者之间无显式关联； Go语言主要有两种组合方式： 垂直组合（类型组合）：Go语言主要通过类型嵌入机制实现垂直组合，进而实现方法实现的复用、接口定义重用等。 水平组合：通常Go程序以接口类型变量作为程序水平组合的连接点。接口是水平组合的关键，它就好比程序肌体上的关节，给予连接关节的两个部分或多个部分各自自由活动的能力，而整体又实现了某种功能。 2. 垂直组合回顾 Go语言通过类型的垂直组合而不是继承让单一类型承载更多的功能； 由于不是继承， 所以也就没有“父子类型”的概念，也没有向上、向下转型； 被嵌入的类型也不知道将其嵌入的外部类型的存在； 调用方法时，方法的匹配取决于方法名称，而不是类型； 通过嵌入接口构建接口 通过嵌入接口构建结构体 通过嵌入结构体构建新结构体 3. 以接口为连接点的水平组合 3.1. 基本形式 水平组合的基本形式是接受接口类型参数的函数或方法： func YourFuncName(param YourInterfaceType) 水平组合的基本形式如图所⽰，从中可以看到，函数/方法参数中的接口类型作为连接点，将位于多个包中的多个类型“编织”到一起，共同形成一幅程序“骨架”： 3.2. 包裹函数 包裹函数：它接受接口类型参数，并返回预期参数类型相同的返回值： func YourWrapperFunc(param YourInterfaceType) YourInterfaceType 通过包裹函数可以实现对输入数据的过滤、装饰、变换等操作， 并将结果再次返回给调用者。而且由于包裹函数的返回值类型与参数类型相同，因此我们可以将多个接受同一接口类型参数的包裹函数组合成一条链来调用： YourWrapperFunc1(YourWrapperFunc2(YourWrapperFunc3(...))) 3.3. 适配器函数类型 适配器函数类型（adapter function type） 是一个辅助水平组合实现的“工具”类型 它可以将一个满足特定函数签名的普通函数显式转换成自身类型的实例，转换后的实例同时也是某个单方法接口类型的实现者 // $GOROOT/src/net/http/server.go type Handler interface { ServeHTTP(ResponseWriter, *Request) } type HandlerFunc func(ResponseWriter, *Request) func (f HandlerFunc) ServeHTTP(w ResponseWriter, r *Request) { f(w, r) } // chapter5/sources/horizontal-composition-3.go func greetings(w http.ResponseWriter, r *http.Request) { fmt.Fprintf(w, \"Welcome!\") } func main() { http.ListenAndServe(\":8080\", http.HandlerFunc(greetings)) } 3.4. 中间件 实质上，这里的中间件就是包裹函数和适配器函数类型结合的产物。 // chapter5/sources/horizontal-composition-4.go func validateAuth(s string) error { if s != \"123456\" { return fmt.Errorf(\"%s\", \"bad auth token\") } return nil } func greetings(w http.ResponseWriter, r *http.Request) { fmt.Fprintf(w, \"Welcome!\") } func logHandler(h http.Handler) http.Handler { return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) { t := time.Now() log.Printf(\"[%s] %q %v\\n\", r.Method, r.URL.String(), t) h.ServeHTTP(w, r) }) } func authHandler(h http.Handler) http.Handler { return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) { err := validateAuth(r.Header.Get(\"auth\")) if err != nil { http.Error(w, \"bad auth param\", http.StatusUnauthorized) return } h.ServeHTTP(w, r) }) } func main() { http.ListenAndServe(\":8080\", logHandler(authHandler(http.HandlerFunc(greetings)))) } $ go run horizontal-composition-4.go $curl http://localhost:8080 bad auth param $curl -H \"auth:123456\" localhost:8080/ Welcome! 我们看到所谓中间件（如logHandler、authHandler）本质上就是一个包裹函数（支持链式调用），但其内部利用了适配器函数类型（http.HandlerFunc）将一个普通函数（如例子中的几个匿名函数）转 换为实现了http.Handler的类型的实例，并将其作为返回值返回。 By YangXin Xu            updated 2023-10-05 22:01:47 "},"第30条-使用接口提高代码的可测试性.html":{"url":"第30条-使用接口提高代码的可测试性.html","title":"第30条-使用接口提高代码的可测试性","keywords":"","body":"（略） Go语言有一个惯例是让单元测试代码时刻伴随着你编写的Go代码。 适当抽取接口，让接口成为好代码与单元测试之间的桥梁是Go语言的一种最佳实践。 By YangXin Xu            updated 2023-10-05 22:04:20 "},"第31条-优先考虑并发设计.html":{"url":"第31条-优先考虑并发设计.html","title":"第31条-优先考虑并发设计","keywords":"","body":"1. 并发与并行1.1.1. 并行方案1.2. 并发方案2. Go并发设计实例2.1. 顺序设计2.2. 并行方案2.3. 并发方案 并发不是并行，并发关乎结构，并行关乎执行 ——Rob Pike， Go语言之父 1. 并发与并行 1.1.1. 并行方案 并行方案 就是在处理器核数重组的情况下 启动多个单线程应用的实例 ，这样每个实例运行在一个核上，从而尽可能多地利用多和计算资源。 但这种方案是有约束的，对于那些不支持在同一环境下部署多实例或同一用户仅能部署一个实例的应用，用传统的部署方式使之并行运行是有难度的甚至是无法实现的。不过近些年兴起的轻量级容器技术可以在一定程度上促成此方案。 1.2. 并发方案 并发方案 就是重新做应用结构设计，将应用分解成多个在基本执行单元中执行的、可能有一定关联关系的代码片段（图中的模块1〜模块 N）： Go语言的设计哲学之一是“原生并发，轻量高效”。Go并未使用操作系统线程作为承载分解后的代码片段（模块）的基本执行单元，而是实现了goroutine这一由Go运行时负责调度的用户层轻量级线程为并 发程序设计提供原生支持。其优势如下： 资源占用小，每个goroutine的初始栈大小仅为2KB。 由Go运行时而不是操作系统调度，goroutine上下文切换代价较小。 语言原生支持：goroutine由go关键字接函数或方法创建，函数或方法返回即表示goroutine退出，开发体验更佳。 语言内置channel作为goroutine间通信原语，为并发设计提供强大支撑。 因此，在应用的结构设计阶段，Go的惯例是优先考虑并发设计。这样做更多是考虑到随着外界环境的变化，经过并发设计的Go应用可以更好、更自然地适应规模化。 2. Go并发设计实例 下面是一个模拟机场安检的例子： 排队旅客（passenger）：代表应用的外部请求。 机场工作人员：代表计算资源。 安检程序：代表应用，必须在获取机场工作人员后才能工作。模拟安检例⼦中，安检程序内部流程包括 登机身份检查 （idCheck）、人身检查（bodyCheck）和X光机对随身物品的检查（xRayCheck）。 安检通道（channel）：每个通道对应一个应用程序的实例。 2.1. 顺序设计 2.2. 并行方案 2.3. 并发方案 By YangXin Xu            updated 2023-10-05 22:48:47 "},"第32条-了解goroutine的调度原理.html":{"url":"第32条-了解goroutine的调度原理.html","title":"第32条-了解goroutine的调度原理","keywords":"","body":"1. goroutine调度器2. goroutine调度模型和演进过程2.1. G-M模型2.2. G-P-M模型2.3. 抢占式调度2.4. NUMA调度模型2.5. 其他优化3. 对goroutine调度器原理的进一步理解3.1. G、P、M3.2. G被抢占调度3.3. channel阻塞或网络I/O情况下的调度3.4. 系统调用阻塞情况下的调度4. 调度器状态的查看方法1. goroutine调度器 Go采用用户层轻量级线程来解决这些问题，并将之称为goroutine。 由于一个goroutine占用资源很少，一个Go程序中可以创建成千上万个并发的goroutine。 而将这些goroutine按照一定算法放到CPU上执行的程序就称为goroutine调度器（goroutine scheduler）。 一个Go程序对于操作系统来说只是一个用户层程序，操作系统眼中只有线程， goroutine的调度全要靠Go自己完成。 2. goroutine调度模型和演进过程 2.1. G-M模型 Go 1.0版本中实现了一个简单的goroutine调度器，此调度器使用 G-M模型 ：每个goroutine对应于运行时中的一个抽象结构——G（goroutine），而被视作“物理 CPU”的操作系统线程则被抽象为另一个结构——M（machine） 但是这个调度器存在诸多问题： 单一全局互斥锁（Sched.Lock）和集中状态存储的存在导致所有goroutine相关操作（如创建、重新调度等）都要上锁。 goroutine传递问题：经常在M之间传递“可运行”的goroutine会导致调度延迟增大，带来额外的性能损耗。 每个M都做内存缓存，导致内存占用过高，数据局部性较差。 因系统调用（syscall）而形成的频繁的工作线程阻塞和解除阻塞会带来额外的性能损耗。 2.2. G-P-M模型 有人曾说过：“计算机科学领域的任何问题都可以通过增加一个间接的中间层来解决。” 发现了G-M模型的不足后，Dmitry Vyukov亲自操刀改进了goroutine调度器，在Go 1.1版本中实现了G-P-M调度模型和work stealing算法，这个模型一直沿用至今，如图所示： 2.3. 抢占式调度 Dmitry Vyukov又提出了“Go抢占式调度器设计”（Go Preemptive Scheduler Design），并在Go 1.2版本中实现了抢占式调度。 这个抢占式调度的原理是在每个函数或方法的入口加上一段额外的代码，让运行时有机会检查是否需要执行抢占调度。 这种协作式抢占调度的解决方案只是局部解决了“饿死”问题，对于没有函数调用而是纯算法循环计算的G，goroutine调度器依然无法抢占。 2.4. NUMA调度模型 Dmitry Vyukov在2014年9月提出了一个新的设计草案文档“NUMA‐aware scheduler for Go”，作为对未来goroutine调度器演进方向的一个提案，不过这个提案至今也没有被列入开发计划。 2.5. 其他优化 Go运行时已经实现了netpoller，这使得即便G发起网络I/O操作也不会导致M被阻塞（仅阻塞G），因而不会导致大量线程（M）被创建出来。 Go开发团队的Ian Lance Taylor在Go 1.9版本中增加了一个针对文件I/O的Poller，它可以像netpoller那样，在G操作那些支持监听的 （pollable）文件描述符时，仅阻塞G，而不会阻塞M。 3. 对goroutine调度器原理的进一步理解 3.1. G、P、M G：代表goroutine，存储了goroutine的执行栈信息、goroutine状态、goroutine的任务函数等。另外G对象是可重用的 P：代表逻辑processor，P的数量决定了系统内最大可并行的G的数量（前提：系统的物理CPU核数>=P的数量）。P中最有用的是其拥有的各种G对象队列、链表、一些缓存和状态。 M：代表真正的执行计算资源。在绑定有效的P后，进入一个调度循环；而调度循环的机制大致是从各种队列、P的本地运行队列中获取G，切换到G的执行栈上并执行G的函数，调用goexit做清理工作并回到M。 // $GOROOT/src/runtime/runtime2.go type g struct { stack stack sched gobuf goid int64 gopc uintptr startpc uintptr ... } type p struct { lock mutex id int32 status uint32 mcache *mcache racectx uintptr // 处于可运行状态的goroutine队列，访问队列⽆须加锁 runqhead uint32 runqtail uint32 runq [256]guintptr runnext guintptr // 可重用的G (状态 == Gdead) gfree *g gfreecnt int32 ... } type m struct { g0 *g mstartfn func() curg *g ... } 3.2. G被抢占调度 与操作系统按时间片调度线程不同，Go中并没有时间片的概念。G是被抢占调度的。 在Go程序启动时，运行时会启动一个名为 sysmon 的M（一般称为监控线程），该M的特殊之处在于它无须绑定P即可运行（以g0这个G的形式）。 sysmon 每20us~10ms启动一次，主要完成如下工作： 释放闲置超过5分钟的span物理内存； 如果超过2分钟没有垃圾回收，强制执行； 将长时间未处理的netpoll结果添加到任务队列； 向长时间运行的G任务发出抢占调度； 收回因syscall长时间阻塞的P； 3.3. channel阻塞或网络I/O情况下的调度 如果G被阻塞在某个channel操作或网络I/O操作上，那么G会被放置到某个等待队列中，而M会尝试运行P的下一个可运行的G； 如果此时P没有可运行的G供M运行，那么M将解绑P，并进入挂起状态； 当I/O操作完成或channel操作完成，在等待队列中的G会被唤醒，标记为runnable，并被放入某个P的队列中，绑定一个M后继续执 行； 3.4. 系统调用阻塞情况下的调度 如果G被阻塞在某个系统调用上，那么不仅G会阻塞，执行该G的M也会解绑P（实质是被sysmon抢走了），与G一起进入阻塞状态； 如果此时有空闲的M，则P会与其绑定并继续执行其他G； 如果没有空闲的M，但仍然有其他G要执行，那么就会创建一个新M； 当系统调用返回后，阻塞在该系统调用上的G会尝试获取一个可用的P，如果有可用P，之前运行该G的M将绑定P继续运行G； 如果没有可用的P，那么G与M之间的关联将解除，同时G会被标记为runnable，放入全局的运行队列中，等待调度器的再次调度； 4. 调度器状态的查看方法 （略） By YangXin Xu            updated 2023-10-06 09:58:22 "},"第33条-掌握Go并发模型和常见并发模式.html":{"url":"第33条-掌握Go并发模型和常见并发模式.html","title":"第33条-掌握Go并发模型和常见并发模式","keywords":"","body":"1. Go并发模型2. Go常见的并发模型2.1. 创建模式2.2. 退出模式2.2.1. 分离模式2.2.2. join模式2.2.3. notify-and-wait模式2.2.4. 退出模式的应用2.3. 管道模式2.4. 扇出和扇入模式2.5. 超时与取消模式 不要通过共享内存来通信，而应该通过通信来共享内存。 ——Rob Pike，Go语言之父 1. Go并发模型 传统语言的并发模型是基于共享内存的模型，如下图所示。这种模型难用且易错： Go语言在新并发模型设计中借鉴了著名计算机科学家Tony Hoare提出的 CSP（Communicating Sequential Process，通信顺序进程）模型 ，如下图所示： CSP模型旨在简化并发程序的编写，让并发程序的编写与编写顺序程序一样简单。 CSP理论中的P（Process，进程）是个抽象概念，它代表任何顺序处理逻辑的封装，它获取输入数据（或从其他P的输出获取），并生产可以被其他P消费的输出数据。 因此，在Tony Hoare眼中，一个符合CSP模型的并发程序应该是一组通过输入/输出原 语连接起来的P的集合。 为了实现CSP模型中的输入/输出原语，Go引入了goroutine（P）之间的通信原语channel。 goroutine可以从channel获取输入数据，再将处理后得到的结果数据通过channel输出。 虽然CSP模型已经成为Go语言支持的主流并发模型，但Go也支持传统的基于共享内存的并发模型，并提供基本的低级同步原语（主要是sync包中的互斥锁、条件变量、读写锁、原子操作等）。 但是Go始终推荐以CSP模型风格构建并发程序。不过对于局部情况，比如涉及性能敏感的区域或需要保护的结构体数据，可以使用更为高效的低级同步原语（如sync.Mutex）。 2. Go常见的并发模型 在语言层面，Go针对CSP模型提供了三种并发原语： goroutine：对应CSP模型中的P，封装了数据的处理逻辑，是Go运行时调度的基本执行单元。 channel：对应CSP模型中的输入/输出原语，用于goroutine之间的通信和同步。 select：用于应对多路输入/输出，可以让goroutine同时协调处理多个channel操作。 2.1. 创建模式 type T struct {...} func spawn(f func()) chan T { c := make(chan T) go func() { // 使用channel变量c(通过闭包⽅式)与调用spawn的goroutine通信 ... f() ... }() return c } func main() { c := spawn(func(){}) // 使用channel变量c与新创建的goroutine通信 } 以上方式在内部创建一个goroutine并返回一个channel类型变量的函数，这是Go中最常见的goroutine创建模式。 2.2. 退出模式 在多数情况下，我们无须考虑对goroutine的退出进行控制：goroutine的执行函数返回，即意味着goroutine退出。但一些常驻的后台服务程序可能会对goroutine有着优雅退出的要求，在这里我们就分类说明一下goroutine的几种退出模式： 2.2.1. 分离模式 对于分离的goroutine，创建它的goroutine不需要关心它的退出。这类goroutine在启动后即与其创建者彻底分离，其生命周期与其执行的主函数相关，函数返回即goroutine退出： 一次性任务：新创建的goroutine用来执行一个简单的任务，执行后即退出： // $GOROOT/src/net/dial.go func (d *Dialer) DialContext(ctx context.Context, network, address string) (Conn, error) { ... if oldCancel := d.Cancel; oldCancel != nil { subCtx, cancel := context.WithCancel(ctx) defer cancel() go func() { select { case 常驻后台任务：其实现通常采用 for {...} 或 for { select { ... } } 代码段形式，并多以定时器或事件驱动执行。 // $GOROOT/src/runtime/mgc.go func gcBgMarkStartWorkers() { // 每个P都有一个运行在后台的用于标记的G for _, p := range allp { if p.gcBgMarkWorker == 0 { go gcBgMarkWorker(p) // 为每个P创建一个goroutine，以运行gcBgMarkWorker notetsleepg(&work.bgMarkReady, -1) noteclear(&work.bgMarkReady) } } } func gcBgMarkWorker(_p_ *p) { gp := getg() ... for { // 常驻后台处理GC事宜 ... } } 2.2.2. join模式 goroutine需要等待新goroutine结束。 等待一个goroutine退出 // chapter6/sources/go-concurrency-pattern-1.go func worker(args ...interface{}) { if len(args) == 0 { return } interval, ok := args[0].(int) if !ok { return } time.Sleep(time.Second * (time.Duration(interval))) } func spawn(f func(args ...interface{}), args ...interface{}) chan struct{} { c := make(chan struct{}) go func() { f(args...) c $ go run go-concurrency-pattern-1.go spawn a worker goroutine worker done 获取goroutine的退出状态 // chapter6/sources/go-concurrency-pattern-2.go var OK = errors.New(\"ok\") func worker(args ...interface{}) error { if len(args) == 0 { return errors.New(\"invalid args\") } interval, ok := args[0].(int) if !ok { return errors.New(\"invalid interval arg\") } time.Sleep(time.Second * (time.Duration(interval))) return OK } func spawn(f func(args ...interface{}) error, args ...interface{}) chan error { c := make(chan error) go func() { c $go run go-concurrency-pattern-2.go spawn worker1 worker1 done: ok spawn worker2 worker2 done: invalid args 等待多个goroutine退出 // chapter6/sources/go-concurrency-pattern-3.go func worker(args ...interface{}) { if len(args) == 0 { return } interval, ok := args[0].(int) if !ok { return } time.Sleep(time.Second * (time.Duration(interval))) } func spawnGroup(n int, f func(args ...interface{}), args ...interface{}) chan struct{} { c := make(chan struct{}) var wg sync.WaitGroup for i := 0; i $go run go-concurrency-pattern-3.go spawn a group of workers worker-2: done worker-1: done worker-0: done worker-4: done worker-3: done group workers done 支持超时机制的等待 // chapter6/sources/go-concurrency-pattern-4.go func main() { done := spawnGroup(5, worker, 30) println(\"spawn a group of workers\") timer := time.NewTimer(time.Second * 5) defer timer.Stop() select { case $ go run go-concurrency-pattern-4.go spawn a group of workers wait group workers exit timeout! 2.2.3. notify-and-wait模式 通知并等待一个goroutine退出 // chapter6/sources/go-concurrency-pattern-5.go func worker(j int) { time.Sleep(time.Second * (time.Duration(j))) } func spawn(f func(int)) chan string { quit := make(chan string) go func() { var job chan int // 模拟job channel for { select { case j := $go run go-concurrency-pattern-5.go spawn a worker goroutine notify the worker to exit... worker done: ok 通知并等待多个goroutine退出 // chapter6/sources/go-concurrency-pattern-6.go func worker(j int) { time.Sleep(time.Second * (time.Duration(j))) } func spawnGroup(n int, f func(int)) chan struct{} { quit := make(chan struct{}) job := make(chan int) var wg sync.WaitGroup for i := 0; i $go run go-concurrency-pattern-6.go spawn a group of workers notify the worker group to exit... worker-3: done worker-0: done worker-4: done worker-2: done worker-1: done group workers done 2.2.4. 退出模式的应用 （略） 2.3. 管道模式 Unix/Linux的管道机制就是将前面程序的输出数据作为输入数据传递给后面的程序 管道是Unix/Linux上一种典型的并发程序设计模式，也是Unix崇尚“组合”设计哲学的具体体现 具有深厚Unix文化背景的Go语言缔造者们显然借鉴了Unix的设计哲学，在Go中引入了channel这种并发原语，如下所示： // chapter6/sources/go-concurrency-pattern-8.go func newNumGenerator(start, count int) $go run go-concurrency-pattern-8.go 4 16 36 64 100 144 196 256 324 400 2.4. 扇出和扇入模式 扇出模式在某个处理环节，多个功能相同的goroutine从同一个channel读取数据并处理，直到该channel关闭，这种情况被称为“扇出”（fanout）。使用扇出模式可以在一组goroutine中均衡分配工作量，从而更均衡地利用CPU。 扇入模式在某个处理环节，处理程序面对不止一个输入channel。我们把所有输入channel的数据汇聚到一个统一的输入channel，然后处理程序再从这个channel中读取数据并处理，直到该channel因所有输入channel关闭而关闭。这种情况被称为“扇入”（fan-in）。 // chapter6/sources/go-concurrency-pattern-9.go func newNumGenerator(start, count int) groupOut // / // out --/ // go func() { var wg sync.WaitGroup for _, out := range outSlice { wg.Add(1) go func(out $ go run go-concurrency-pattern-9.go square-1: begin to work... filterOdd-1: begin to work... square-0: begin to work... filterOdd-2: begin to work... filterOdd-0: begin to work... filterOdd-1: work done 4 16 36 100 64 144 324 400 256 196 filterOdd-2: work done filterOdd-0: work done square-0: work done square-1: work done 2.5. 超时与取消模式 （略） By YangXin Xu            updated 2023-10-06 12:12:44 "},"第34条-了解channel的妙用.html":{"url":"第34条-了解channel的妙用.html","title":"第34条-了解channel的妙用","keywords":"","body":"1. 无缓冲channel1.1. 用作信号传递1.1.1. 一对一通知信号1.1.2. 一对多通知信号1.2. 用于替代锁机制2. 带缓冲channel2.1. 用作消息队列2.2. 用作计数信号量2.3. len(channel)的应用3. nil channel的妙用4. 与select结合使用的一些惯用法4.1. 利用default分支避免阻塞4.2. 实现超时机制4.3. 实现心跳机制 channel类型在Go中为“一等公民”，因此channel原语使用起来很简单： c := make(chan int) // 创建一个⽆缓冲(unbuffered)的int类型的channel c := make(chan int, 5) // 创建一个带缓冲的int类型的channel c 当需要同时对多个channel进行操作时，我们会结合使用Go为CSP模型提供的另一个原语：select。通过select，我们可以同时在多个channel上进行发送/接收操作： select { case x := 1. 无缓冲channel 无缓冲channel间距通信性和同步性，可以通过不带有capacity参数的内置make函数创建一个可用的无缓冲channel： c := make(chan T) // T为channel中元素的类型 对于无缓冲channel而言，我们得到以下结论： 发送动作一定发生在接收动作完成之前； 接收动作一定发生在发送动作完成之前； 1.1. 用作信号传递 1.1.1. 一对一通知信号 // chapter6/sources/go-channel-case-2.go type signal struct{} func worker() { println(\"worker is working...\") time.Sleep(1 * time.Second) } func spawn(f func()) $go run go-channel-case-2.go start a worker... worker start to work... worker is working... worker work done! 1.1.2. 一对多通知信号 通知一组goroutine开始工作 // chapter6/sources/go-channel-case-3.go type signal struct{} func worker(i int) { fmt.Printf(\"worker %d: is working...\\n\", i) time.Sleep(1 * time.Second) fmt.Printf(\"worker %d: works done\\n\", i) } func spawnGroup(f func(i int), num int, groupSignal $go run go-channel-case-3.go start a group of workers... the group of workers start to work... worker 3: start to work... worker 3: is working... worker 4: start to work... worker 4: is working... worker 1: start to work... worker 1: is working... worker 5: start to work... worker 5: is working... worker 2: start to work... worker 2: is working... worker 3: works done worker 4: works done worker 5: works done worker 1: works done worker 2: works done the group of workers work done! 通知一组goroutine退出 // chapter6/sources/go-channel-case-4.go type signal struct{} func worker(i int, quit $go run go-channel-case-4.go start a group of workers... the group of workers start to work... worker 1: start to work... worker 1: is working... worker 3: start to work... worker 3: is working... worker 5: start to work... worker 5: is working... worker 4: start to work... worker 4: is working... worker 2: start to work... worker 2: is working... notify the group of workers to exit... worker 2: works done worker 4: works done worker 5: works done worker 1: works done worker 3: works done the group of workers work done! 1.2. 用于替代锁机制 无缓冲channel具有同步特性，这让它在某些场合可以替代锁，从而使得程序更加清晰，可读性更好。 // chapter6/sources/go-channel-case-6.go type counter struct { c chan int i int } var cter counter func InitCounter() { cter = counter{ c: make(chan int), } go func() { for { cter.i++ cter.c $go run go-channel-case-6.go counter init ok goroutine-9: current counter value is 10 goroutine-0: current counter value is 1 goroutine-6: current counter value is 7 goroutine-2: current counter value is 3 goroutine-8: current counter value is 9 goroutine-4: current counter value is 5 goroutine-5: current counter value is 6 goroutine-1: current counter value is 2 goroutine-7: current counter value is 8 goroutine-3: current counter value is 4 2. 带缓冲channel 带缓冲channel可以通过带有capacity参数的内置make函数创建： c := make(chan T, capacity) // T为channel中元素的类型, capacity为 带缓冲channel的缓冲 对一个带缓冲channel： 在缓冲区无数据或有数据但未满的情况下，对其进行发送操作的goroutine不会阻塞； 在缓冲区已满的情况下，对其进行发送操作的goroutine会阻塞； 在缓冲区为空的情况下，对其进行接收操作的goroutine会阻塞； 2.1. 用作消息队列 单收单发性能基准测试 // ⽆缓冲channel // chapter6/sources/go-channel-operation-benchmark/unbuffered\u0002chan $go test -bench . one_to_one_test.go goos: darwin goarch: amd64 BenchmarkUnbufferedChan1To1Send-8 6202120 198 ns/op BenchmarkUnbufferedChan1To1Recv-8 6752820 178 ns/op PASS // 带缓冲channel // chapter6/sources/go-channel-operation-benchmark/buffered\u0002chan $go test -bench . one_to_one_cap_10_test.go goos: darwin goarch: amd64 BenchmarkBufferedChan1To1SendCap10-8 14397186 83.7 ns/op BenchmarkBufferedChan1To1RecvCap10-8 14275723 82.2 ns/op PASS $go test -bench . one_to_one_cap_100_test.go goos: darwin goarch: amd64 BenchmarkBufferedChan1To1SendCap100-8 18011007 65.5 ns/op BenchmarkBufferedChan1To1RecvCap100-8 18031082 65.4 ns/op PASS 多收多发性能基准测试 // ⽆缓冲channel // chapter6/sources/go-channel-operation-benchmark/unbuffered\u0002chan $go test -bench . multi_to_multi_test.go goos: darwin goarch: amd64 BenchmarkUnbufferedChanNToNSend-8 317324 3793 ns/op BenchmarkUnbufferedChanNToNRecv-8 295288 4139 ns/op PASS // 带缓冲channel // chapter6/sources/go-channel-operation-benchmark/buffered\u0002chan $go test -bench . multi_to_multi_cap_10_test.go goos: darwin goarch: amd64 BenchmarkBufferedChanNToNSendCap10-8 534625 2252 ns/op BenchmarkBufferedChanNToNRecvCap10-8 476221 2752 ns/op PASS $go test -bench . multi_to_multi_cap_100_test.go goos: darwin goarch: amd64 BenchmarkBufferedChanNToNSendCap100-8 1000000 1283 ns/op BenchmarkBufferedChanNToNRecvCap100-8 1000000 1250 ns/op PASS 2.2. 用作计数信号量 Go并发设计的一个惯用法是将带缓冲channel用作计数信号量（counting semaphore） 一个发往带缓冲channel的发送操作表示获取一个信号量槽位，而一个来自带缓冲channel的接收操作则表示释放一个信号量槽位 // chapter6/sources/go-channel-case-7.go var active = make(chan struct{}, 3) var jobs = make(chan int, 10) func main() { go func() { for i := 0; i $go run go-channel-case-7.go 2020/02/04 09:57:02 handle job: 8 2020/02/04 09:57:02 handle job: 4 2020/02/04 09:57:02 handle job: 1 2020/02/04 09:57:04 handle job: 2 2020/02/04 09:57:04 handle job: 3 2020/02/04 09:57:04 handle job: 7 2020/02/04 09:57:06 handle job: 6 2020/02/04 09:57:06 handle job: 5 2.3. len(channel)的应用 len是Go语言原生内置的函数，它可以接受数组、切片、map、字符串或channel类型的参数，并返回对应类型的“长度”——一个整型值。以len(s)为例： 如果s是字符串（string）类型，len(s)返回字符串中的字节数； 如何s是[n]T或*[n]T的数组类型，len(s)返回数组的长度n； 如果s是[]T的切片（slice）类型，len(s)返回切片的当前长度； 如果s是map[K]T的map类型，len(s)返回map中已定义的key的个数； 如果s是chan T类型，那么len(s)针对channel的类型不同，有如下两种语义： 当s为无缓冲channel时，len(s)总是返回0； 当s为带缓冲channel时，len(s)返回当前channel s中尚未被读取的元素个数； 3. nil channel的妙用 对没有初始化的channel（nil channel）进行读写操作将会发生阻塞，并得到如下的错误信息： fatal error: all goroutines are asleep - deadlock! goroutine 1 [chan receive (nil chan)]: 但是nil channel并非一无是处： // chapter6/sources/go-channel-case-10.go func main() { c1, c2 := make(chan int), make(chan int) go func() { time.Sleep(time.Second * 5) c1 $go run go-channel-case-10.go 5 7 program end 4. 与select结合使用的一些惯用法 4.1. 利用default分支避免阻塞 select语句的default分支的语义是在其他分支均因通信未就绪或无法被选择的时候执行，这就为default分支赋予了一种“避免阻塞”的特性。在Go标准库中，这个惯用法也有应用： // $GOROOT/src/time/sleep.go func sendTime(c interface{}, seq uintptr) { // ⽆阻塞地向c发送当前时间 // ... select { case c.(chan Time) 4.2. 实现超时机制 带超时机制的select是Go语义中一种常见的select和channel的组和用法 在应用带有超时机制的select时，要特别注意timer使用后的释放，尤其是在大量创建timer时 Go语言标准库提供的timer实质上是由Go运行时自行维护的，而非操作系统级的定时器资源 func worker() { select { case 4.3. 实现心跳机制 结合time包的Ticker，我们可以实现带有心跳机制的select 这种机制使我们可以在监听channel的同时，执行一些周期性的任务 func worker() { heartbeat := time.NewTicker(30 * time.Second) defer heartbeat.Stop() for { select { case By YangXin Xu            updated 2023-10-06 14:21:11 "},"第35条-了解sync包的正确用法.html":{"url":"第35条-了解sync包的正确用法.html","title":"第35条-了解sync包的正确用法","keywords":"","body":"1. 使用sync包的注意事项2. 互斥锁还是读写锁3. 条件变量 Go语义在提供CSP并发模型原语的同时，还通过标准库的sync包提供了针对传统基于共享内存并发模型的基本同步原语，包括互斥锁（sync.Mutex）、读写锁（sync.RWMutex）、条件变量（sync.Cond）等。 1. 使用sync包的注意事项 在$GOROOT/src/sync/mutex.go文件中，我们看到这样一行关于使用sync包的注意事项： // Values containing the types defined in this package should not be copied. // 不应复制那些包含了此包中类型的值 因为Metex等sync包中定义的结构类型首次使用后如果被复制，会导致锁副本的产生，从而导致进程之间并没有共享同一个锁，可能会引发死锁问题 Go标准库中sync.Mutex的定义如下： // $GOROOT/src/sync/mutex.go type Mutex struct { state int32 sema uint32 } state：表示当前互斥锁的状态 sema：用于控制锁状态的信号量 那些sync包中类型的实例在首次使用后被复制得到的副本一旦再被使用将导致不可预期的结果，为此在使用sync包中类型时，推荐通过 闭包方式或传递类型实例的地址或指针 的方式进行，这是使用sync包最值得注意的事项。 2. 互斥锁还是读写锁 互斥锁 是临界区同步原语的首选，它常被用来对结构体对象的内部状态、缓存等进行保护，是使用最为广泛的临界区同步原语。 相比之下，读写锁 颇受“冷落”，但它依然有其存在的道理和适用的场景。 总的来说： 在并发量较小的情况下，互斥锁性能更好； 随着并发量增大，互斥锁的竞争激烈，导致加锁和解锁性能下降。 读写锁的读锁性能并未随并发量的增大而发生较大变化，性能始终恒定在40ns左右。 在并发量较大的情况下，读写锁的写锁性能比互斥锁、读写锁的读锁都差，并且随着并发量增大，其写锁性能有继续下降的趋势。 由此我们可以看出，读写锁适合应用在具有一定并发量且读多写少的场合 3. 条件变量 sync.Cond是传统的条件变量原语概念在Go语言中的实现。 一个条件变量可以理解为一个容器，这个容器中存放着一个或一组等待着某个条件成立的goroutine。 当条件成立时，这些处于等待状态的goroutine将得到通知并被唤醒以继续后续的工作。 // chapter6/sources/go-sync-package-5.go type signal struct{} var ready bool func worker(i int) { fmt.Printf(\"worker %d: is working...\\n\", i) time.Sleep(1 * time.Second) fmt.Printf(\"worker %d: works done\\n\", i) } func spawnGroup(f func(i int), num int, groupSignal *sync.Cond) $go run go-sync-package-5.go start a group of workers... the group of workers start to work... worker 4: start to work... worker 4: is working... worker 1: start to work... worker 1: is working... worker 3: start to work... worker 3: is working... worker 5: start to work... worker 5: is working... worker 2: start to work... worker 2: is working... worker 1: works done worker 3: works done worker 4: works done worker 2: works done worker 5: works done the group of workers work done! By YangXin Xu            updated 2023-10-06 14:46:46 "},"第36条-使用atomic包实现伸缩性更好的并发读取.html":{"url":"第36条-使用atomic包实现伸缩性更好的并发读取.html","title":"第36条-使用atomic包实现伸缩性更好的并发读取","keywords":"","body":"1. atomic包与原子操作2. 对共享整型变量的无锁读写3. 对共享自定义类型变量的无锁读写4. 小结 面向CSP并发模型的channel原语和面向传统共享内存并发模型的sync包提供的原语已经足以满足Go语⾔应用并发设计中99.9%的并发同步需求了，而剩余那0.1%的需求，可以使用Go标准库提供的atomic包来实现。 1. atomic包与原子操作 atomic包是Go语言提供的原子操作原语的相关接口； 原子操作的指令是不可中断的，要么不执行，一旦执行就一次性全部执行完毕，不可分割； 原子操作由底层硬件直接提供支持，是一种硬件实现的指令级“事务”，相比于操作系统层面的sync包、Go运行时层面的channel，它更为原始； atomic包封装了CPU实现的部分原子操作指令，为用户层提供体验良好的原子操作函数 以atomic.SwapInt64函数在x86_64平台上的实现为例： // $GOROOT/src/sync/atomic/doc.go func SwapInt64(addr *int64, new int64) (old int64) // $GOROOT/src/sync/atomic/asm.s TEXT ·SwapInt64(SB),NOSPLIT,$0 JMP runtime∕internal∕atomic·Xchg64(SB) // $GOROOT/src/runtime/internal/asm_amd64.s TEXT runtime∕internal∕atomic·Xchg64(SB), NOSPLIT, $0-24 MOVQ ptr+0(FP), BX MOVQ new+8(FP), AX XCHGQ AX, 0(BX) MOVQ AX, ret+16(FP) RET SwapInt64基本上就是对 x86_64 CPU实现的原子操作指令 XCHGQ 的直接封装 2. 对共享整型变量的无锁读写 atomic包提供了两大类原子操作接口：一类是针对整型变量的，包括有符号整型、无符号整型以及对应的指针类型；另一类是针对自定义类型的。 // chapter6/sources/go-atomic-package-1_test.go var n1 int64 func addSyncByAtomic(delta int64) int64 { return atomic.AddInt64(&n1, delta) } func readSyncByAtomic() int64 { return atomic.LoadInt64(&n1) } var n2 int64 var rwmu sync.RWMutex func addSyncByRWMutex(delta int64) { rwmu.Lock() n2 += delta rwmu.Unlock() } func readSyncByRWMutex() int64 { var n int64 rwmu.RLock() n = n2 rwmu.RUnlock() return n } func BenchmarkAddSyncByAtomic(b *testing.B) { b.RunParallel(func(pb *testing.PB) { for pb.Next() { addSyncByAtomic(1) } }) } func BenchmarkReadSyncByAtomic(b *testing.B) { b.RunParallel(func(pb *testing.PB) { for pb.Next() { readSyncByAtomic() } }) } func BenchmarkAddSyncByRWMutex(b *testing.B) { b.RunParallel(func(pb *testing.PB) { for pb.Next() { addSyncByRWMutex(1) } }) } func BenchmarkReadSyncByRWMutex(b *testing.B) { b.RunParallel(func(pb *testing.PB) { for pb.Next() { readSyncByRWMutex() } }) } $go test -bench . go-atomic-package-1_test.go -cpu 2 goos: darwin goarch: amd64 BenchmarkAddSyncByAtomic-2 56360716 20.4 ns/op BenchmarkReadSyncByAtomic-2 1000000000 0.729 ns/op BenchmarkAddSyncByRWMutex-2 41799388 28.9 ns/op BenchmarkReadSyncByRWMutex-2 35381282 32.6 ns/op PASS $go test -bench . go-atomic-package-1_test.go -cpu 8 goos: darwin goarch: amd64 BenchmarkAddSyncByAtomic-8 58224580 20.5 ns/op BenchmarkReadSyncByAtomic-8 1000000000 0.234 ns/op BenchmarkAddSyncByRWMutex-8 18438339 64.2 ns/op BenchmarkReadSyncByRWMutex-8 29445268 40.8 ns/op PASS $go test -bench . go-atomic-package-1_test.go -cpu 16 goos: darwin goarch: amd64 BenchmarkAddSyncByAtomic-16 58500958 20.4 ns/op BenchmarkReadSyncByAtomic-16 1000000000 0.238 ns/op BenchmarkAddSyncByRWMutex-16 16669366 71.8 ns/op BenchmarkReadSyncByRWMutex-16 29137915 41.2 ns/op PASS $go test -bench . go-atomic-package-1_test.go -cpu 32 goos: darwin goarch: amd64 BenchmarkAddSyncByAtomic-32 58587633 20.4 ns/op BenchmarkReadSyncByAtomic-32 1000000000 0.231 ns/op BenchmarkAddSyncByRWMutex-32 14315090 81.8 ns/op BenchmarkReadSyncByRWMutex-32 29164032 41.1 ns/op PASS 读写锁的性能随着并发量增大的变化情况与前面讲解sync.RWMutex时的一致； 利用原子操作的无锁并发写的性能随着并发量增大几乎保持恒定； 利用原子操作的无锁并发读的性能随着并发量增大有持续提升的趋势，并且性能约为读锁的200倍； 3. 对共享自定义类型变量的无锁读写 atomic通过Value类型的装拆箱操作实现了对任意自定义类型的原子操作（Load 和Store），从而实现对共享自定义类型变量无锁读写的支持。 // chapter6/sources/go-atomic-package-2_test.go type Config struct { sync.RWMutex data string } func BenchmarkRWMutexSet(b *testing.B) { config := Config{} b.ReportAllocs() b.RunParallel(func(pb *testing.PB) { for pb.Next() { config.Lock() config.data = \"hello\" config.Unlock() } }) } func BenchmarkRWMutexGet(b *testing.B) { config := Config{data: \"hello\"} b.ReportAllocs() b.RunParallel(func(pb *testing.PB) { for pb.Next() { config.RLock() _ = config.data config.RUnlock() } }) } func BenchmarkAtomicSet(b *testing.B) { var config atomic.Value c := Config{data: \"hello\"} b.ReportAllocs() b.RunParallel(func(pb *testing.PB) { for pb.Next() { config.Store(c) } }) } func BenchmarkAtomicGet(b *testing.B) { var config atomic.Value config.Store(Config{data: \"hello\"}) b.ReportAllocs() b.RunParallel(func(pb *testing.PB) { for pb.Next() { _ = config.Load().(Config) } }) } $go test -bench . go-atomic-package-2_test.go -cpu=2 goos: darwin goarch: amd64 BenchmarkRWMutexSet-2 40097684 29.3 ns/op 0 B/op 0 allocs/op BenchmarkRWMutexGet-2 37523130 34.7 ns/op 0 B/op 0 allocs/op BenchmarkAtomicSet-2 26030662 44.4 ns/op 48 B/op 1 allocs/op BenchmarkAtomicGet-2 1000000000 0.677 ns/op 0 B/op 0 allocs/op PASS $go test -bench . go-atomic-package-2_test.go -cpu=8 goos: darwin goarch: amd64 BenchmarkRWMutexSet-8 18696680 63.2 ns/op 0 B/op 0 allocs/op BenchmarkRWMutexGet-8 29149304 41.0 ns/op 0 B/op 0 allocs/op BenchmarkAtomicSet-8 42793735 29.1 ns/op 48 B/op 1 allocs/op BenchmarkAtomicGet-8 1000000000 0.346 ns/op 0 B/op 0 allocs/op PASS $go test -bench . go-atomic-package-2_test.go -cpu=16 goos: darwin goarch: amd64 BenchmarkRWMutexSet-16 17499681 68.9 ns/op 0 B/op 0 allocs/op BenchmarkRWMutexGet-16 29048467 41.4 ns/op 0 B/op 0 allocs/op BenchmarkAtomicSet-16 36774126 31.8 ns/op 48 B/op 1 allocs/op BenchmarkAtomicGet-16 1000000000 0.356 ns/op 0 B/op 0 allocs/op PASS $go test -bench . go-atomic-package-2_test.go -cpu=32 goos: darwin goarch: amd64 BenchmarkRWMutexSet-32 17546760 75.9 ns/op 0 B/op 0 allocs/op BenchmarkRWMutexGet-32 34059410 35.3 ns/op 0 B/op 0 allocs/op BenchmarkAtomicSet-32 36702122 33.3 ns/op 48 B/op 1 allocs/op BenchmarkAtomicGet-32 1000000000 0.351 ns/op 0 B/op 0 allocs/op PASS 利用原子操作的无锁并发写的性能随着并发量的增大而小幅下降； 利用原子操作的无锁并发读的性能随着并发量增大有持续提升的趋势，并且性能约为读锁的100倍； 4. 小结 随着并发量提升，使用atomic实现的共享变量的并发读写性能表现更为稳定，尤其是原子读操作，这让atomic与sync包中的原语比起来表现出更好的伸缩性和更高的性能。 由此可以看出atomic包更适合一些对性能十分敏感、并发量较大且读多写少的场合。 但atomic原子操作可用来同步的范围有较大限制，仅是一个整型变量或自定义类型变量。如果要对一个复杂的临界区数据进行同步， 那么首选依旧是sync包中的原语。 By YangXin Xu            updated 2023-10-06 15:15:36 "},"第37条-了解错误处理的4种策略.html":{"url":"第37条-了解错误处理的4种策略.html","title":"第37条-了解错误处理的4种策略","keywords":"","body":"1. 构造错误值2. 透明错误处理策略3. “哨兵”错误处理策略4. 错误值类型检视策略5. 错误行为特征检视策略 Go语言自出生那天起，就因其简单且看起来有些过时的错误处理机制而被大家所诟病。 Go语言没有主流编程语言那样提供基于异常的结构化 try-catch-finally 错误处理机制，Go语言设计者们任务将异常耦合到程序控制结构中会导致代码混乱，并且在那样的机制下，程序员会将大多常见错误标记为异常，这与Go追求简单的价值观背道而驰。 Go语言设计者们选择了C语言家族的经典错误机制：错误就是值，而错误处理就是基于值比较后的决策。 同时，Go结合函数/方法的多返回值机制避免了像C语言那样在单一函数返回值中承载多重信息的问题。 Go这种简单的基于错误值比较的错误处理机制使得每个Go开发人员必须显式地关注和处理每个错误，经过显式错误处理的代码会更为健壮，Go开发人员也会对这些代码更有信心。 Go中的错误不是异常，它就是普通值，我们不需要额外的语言机制去处理它们，而只需利用已有的语言机制，像处理其他普通类型值一样去处理错误。 这也决定了这样的错误处理机制让代码更容易调试（就像对待普通变量值那样），也更容易针对每个错误处理的决策分支进行测试覆盖。 同时， 没有try-catch-finally的异常处理机制也让Go代码的可读性更佳。 1. 构造错误值 错误是值，只是以error接口变量的形式统一呈现： // $GOROOT/src/builtin/builtin.go type interface error { Error() string } 在标准库中，Go提供了构造错误值的两种基本方法——errors.New 和 fmt.Errorf Go 1.13版本之前，这两种方法实际上返回的是同一个实现了error接口的类型的实例： // $GOROOT/src/errors/errors.go type errorString struct { s string } func (e *errorString) Error() string { return e.s } Go 1.13及后续版本中，当我们在格式化字符串中使用 %w 时，fmt.Errorf 返回的错误值的底层类型是 fmt.wrapError： // $GOROOT/src/fmt/errors.go (Go 1.13及后续版本) type wrapError struct { msg string err error } func (e *wrapError) Error() string { return e.msg } func (e *wrapError) Unwrap() error { return e.err } 在一些场景下，错误处理者需要从错误值中提取出更多信息以帮助其选择错误处理路径，这时他们可以自定义错误类型来满足需求。例如： // $GOROOT/src/net/net.go type OpError struct { Op string Net string Source Addr Addr Addr Err error } 2. 透明错误处理策略 Go语言中的错误处理：就是根据函数/方法返回的error类型变量中携带的错误值信息做决策并选择后续代码执行路径的过程。 透明错误处理策略：是最简单的错误策略，他完全不关心错误值携带的具体上下文信息，只要发生错误就进入唯一的错误处理执行路径。这也是Go语言中最常见的错误处理策略。 err := doSomething() if err != nil { // 不关⼼err变量底层错误值所携带的具体上下⽂信息 // 执行简单错误处理逻辑并返回 ... return err } 透明错误处理策略最大程度地减少了错误处理方与错误值构造方之间的耦合关系，它们之间唯一的耦合就是error接口变量所规定的契约。 3. “哨兵”错误处理策略 有时错误处理方会尝试对返回的错误值进行检视，从而出现下面的 反模式： data, err := b.Peek(1) if err != nil { switch err.Error() { case \"bufio: negative count\": // ... return case \"bufio: buffer full\": // ... return case \"bufio: invalid use of UnreadByte\": // ... return default: // ... return } } 但这种反模式会导致严重的隐式耦合：错误值构造方不经意间的一次错误描述字符串的改动，都会造成错误处理方处理行为的变化，并且这种通过字符串比较的方式对错误值进行检视的性能也很差。 所以Go标准库采用了定义导出的“哨兵”错误值的方式来辅助错误处理方检视错误值并做出错误处理分支的决策： // $GOROOT/src/bufio/bufio.go var ( ErrInvalidUnreadByte = errors.New(\"bufio: invalid use of UnreadByte\") ErrInvalidUnreadRune = errors.New(\"bufio: invalid use of UnreadRune\") ErrBufferFull = errors.New(\"bufio: buffer full\") ErrNegativeCount = errors.New(\"bufio: negative count\") ) // 错误处理代码 data, err := b.Peek(1) if err != nil { switch err { case bufio.ErrNegativeCount: // ... return case bufio.ErrBufferFull: // ... return case bufio.ErrInvalidUnreadByte: // ... return default: // ... return } } // 或者 if err := doSomething(); err == bufio.ErrBufferFull { // 处理缓冲区满的错误情况 ... } 从Go 1.13版本开始，标准库errors包提供了Is方法用于错误处理方对错误值进行检视。 不同的是，如果error类型变量的底层错误值是一个包装错误，errors.Is方法会沿着该包装错误所在错误链与链上所有被包装的错误进行比较，直至找到一个匹配的错误。 因此，如果你使用的是Go 1.13及后续版本，请尽量使用errors.Is方法检视某个错误值是不是某个特定的“哨兵”错误值。 4. 错误值类型检视策略 如果想要通过自定义错误类型的构造错误值的方式来提供更多的错误上下文信息，错误处理放需要使用Go提供的 类型断言机制（type assertion） 或 类型选择机制（type switch） 。我们称之为 错误值类型检视策略 // $GOROOT/src/encoding/json/decode.go type UnmarshalTypeError struct { Value string Type reflect.Type Offset int64 Struct string Field string } // $GOROOT/src/encoding/json/decode_test.go // 通过类型断⾔机制获取 func TestUnmarshalTypeError(t *testing.T) { for _, item := range decodeTypeErrorTests { err := Unmarshal([]byte(item.src), item.dest) if _, ok := err.(*UnmarshalTypeError); !ok { t.Errorf(\"expected type error for Unmarshal(%q, type %T): got %T\", item.src, item.dest, err) } } } // $GOROOT/src/encoding/json/decode.go // 通过类型选择机制获取 func (d *decodeState) addErrorContext(err error) error { if d.errorContext.Struct != nil || len(d.errorContext.FieldStack) > 0 { switch err := err.(type) { case *UnmarshalTypeError: err.Struct = d.errorContext.Struct.Name() err.Field = strings.Join(d.errorContext.FieldStack, \".\") return err } } return err } 5. 错误行为特征检视策略 在Go标准库中，我们发现了这样一种错误处理方式：将某个包中的错误类型归类，统一提取出一些公共的错误行为特征，并将这些错误行为特征放入一个公开的接口类型中。 // $GOROOT/src/net/net.go type Error interface { error Timeout() bool // 是超时类错误吗？ Temporary() bool // 是临时性错误吗？ } // $GOROOT/src/net/http/server.go func (srv *Server) Serve(l net.Listener) error { ... for { rw, e := l.Accept() if e != nil { select { case By YangXin Xu            updated 2023-10-06 17:38:52 "},"第39条-不要使用panic进行正常的错误处理.html":{"url":"第39条-不要使用panic进行正常的错误处理.html","title":"第39条-不要使用panic进行正常的错误处理","keywords":"","body":"1. Go的panic不是Java的checked exception1.1. checked exception实质是错误，而panic是异常1.2. API调用中没有义务处理panic1.3. 未被捕获的panic意味着“游戏结束”2. panic的典型应用2.1. 充当断言角色，提示潜在bug2.2. 用于简化错误处理控制结构2.3. 使用recover捕获panic，防止goroutine意外退出3. 理解panic的输出信息 Go的正常错误处理与异常处理之间是泾渭分明的，这与其它主流编程语言使用结构化错误处理统一处理错误与异常说两种不同的理念。 Go提供了panic专门用于处理异常，而我们建议不要使用panic进行正常的错误处理。 1. Go的panic不是Java的checked exception Java的错误处理是建构在整套异常处理机制之上的。 Java中的异常有两种：checked exception 和 unchecked exception 如果一个API抛出checked exception，那么调用该API的外层代码就必须处理该checked exception（要么通过try-catch捕捉，要么重新抛给更上一层处理），否则代码无法通过编译。 API的调用者还可以通过API方法原型中的throws语句显式了解到该API可能会抛出哪些checked exception。 1.1. checked exception实质是错误，而panic是异常 Java的checked exception用于一些可预见的、常会发生的错误场景，针对checked exception的所谓异常处理就是针对这些场景的 错误处理预案 。也可以说对checked exception的使用、捕获、自定义等行为均是 “有意而为之” 。 如果非要与Go中的某种语法对应，那也应该是Go的正常错误处理，即基于显式error模型的显式错误处理。 因此，对checked exception处理的本质是错误处理，虽然名字中带有exception字样。 Go官方博客上的文章 “Defer, Panic, and Recover” 是这么介绍引发panic的panic函数的： panic是一个Go内置函数，它用来停止当前常规控制流并启动panicking过程。当函数F调用panic函数时，函数F的执行停止，函数F中已进行了求值的defer函数都将得到正常执行，然后函数F将控制权返还给其调用者。对于函数F的调用者而言，函数F之后的行为就如同调用者调用的函数是panic一样，该panicking过程将继续在栈上进行下去，直到当前goroutine中的所有函数都返回为止，此时程序将崩溃退出。panic可以通过直接调用panic函数来引发，它们也可能是由运行时错误引起，例如越界数组访问。 和Java中的checked exception的“有意而为之”相反，在Go中，panic则是“不得已而为之”，即所有引发panic的情形，无论是显式的还是隐式的，都是我们不希望看到的。 对于这些引发的panic，我们很少有预案去应对，更多的是让程序快速崩溃掉。因此，Go中的panic更接近于Java 的RuntimeException+Error，而非checked exception 1.2. API调用中没有义务处理panic 在Go中，我们通常会导入大量第三方包，但不知道这些第三方包API中是否会引发panic（⽬前也没有现成的工具去发现），因此上层代码，即API调用者根本不会逐一了解API是否会引发panic，也没有义务去处理引发的panic。 一旦你像使用checked exception那样将panic作为正常错误处理的手段，而在你编写的API中将引发的panic当作错误，那么你就会给你的API调用者带去大麻烦！ 1.3. 未被捕获的panic意味着“游戏结束” 一旦在Go API中引发panic，就像上面提到的，API的调用者并没有义务处理该panic，因此该panic会沿着调用函数栈向上“蔓延”，直到所有函数都返回，调用该API的gorouine将携带着panic信息退出。 一旦panic没有被捕获（recover），他导致的不只是一个goroutine的退出，而是整个Go程序的崩溃。 综上，Go panic不应被当作Java的checked exception来进行正常的错误处理。使用错误和多返回值的显式错误处理方式才符合Go的错误处理哲学。 2. panic的典型应用 我们要尽可能少用panic，避免给上层带去它们也无法处理的情况。 不过，少用不代表不用，关于如何更好地使用panic，Go标准库对panic的使用给了我们⼀些启示。 2.1. 充当断言角色，提示潜在bug 2.2. 用于简化错误处理控制结构 2.3. 使用recover捕获panic，防止goroutine意外退出 3. 理解panic的输出信息 （略） By YangXin Xu            updated 2023-10-06 20:16:00 "},"第40条-理解包内测试与包外测试的差别.html":{"url":"第40条-理解包内测试与包外测试的差别.html","title":"第40条-理解包内测试与包外测试的差别","keywords":"","body":"1. 官方文档的“自相矛盾”2. 包内测试与包外测试2.1. Go标准库中包内测试和包外测试的使用情况2.2. 包内测试2.3. 包外测试2.4. 优先使用包外测试 Go语言在工具链和标准库中提供对测试的原生支持 1. 官方文档的“自相矛盾” 下面示关于testing包的一端官方文档（Go 1.14版本）摘录： 要编写一个新的测试集（test suite），创建一个包含 TestXxx函数的以_test.go为文件名结尾的文件。将这个测试文件放在与被测试包相同的包下面。编译被测试包时，该文件将被排除在外；执行go test时，该文件将被包含在内。 这意味着我们要把对foo包的测试代码放在包名同样为foo的测试文件中。（包内测试） 但在介绍go test命令时，Go文档如是说： 那些包名中带有_test后缀的测试文件将被编译成一个独立的包，这个包之后会被链接到主测试二进制文件中并运行。 这意味着我们要把对foo包的测试代码放在包名为foo_test的测试文件中。（包外测试） 2. 包内测试与包外测试 2.1. Go标准库中包内测试和包外测试的使用情况 在$GOROOT/src目录下（Go 1.14版本），执行下面的命令组合： // 统计标准库中采用包内测试的测试文件数量 $find . -name \"*_test.go\" |xargs grep package |grep ':package'|grep -v \"_test$\"|wc -l 691 // 统计标准库中采用包外测试的测试文件数量 $find . -name \"*_test.go\" |xargs grep package |grep ':package'|grep \"_test$\" |wc -l 448 在$GOROOT/src/net/http目录下，分别执行下面命令： $go list -f={ {.XTestGoFiles} } [alpn_test.go client_test.go clientserver_test.go example_filesystem_test.go example_handle_test.go example_test.go fs_test.go main_test.go request_test.go serve_test.go sniff_test.go transport_test.go] $go list -f={ {.TestGoFiles} } [cookie_test.go export_test.go filetransport_test.go header_test.go http_test.go proxy_test.go range_test.go readrequest_test.go requestwrite_test.go response_test.go responsewrite_test.go server_test.go transfer_test.go transport_internal_test.go] 我们看到，在针对net/http的测试代码中，对包内测试和包外测试的使用仍然不分伯仲。 2.2. 包内测试 优势： 包内测试这种方法本质上是一种白盒测试方法。 由于测试代码与被测包源码在同一包名下，测试代码可以访问该包下的所有符号，无论是导出符号还是未导出符号； 并且由于包的内部实现逻辑对测试代码是透明的，包内测试可以更为直接地构造测试数据和实施测试逻辑，可以很容易地达到较高的测试覆盖率。 不足： 测试代码自身需要经常性的维护：因为包内测试是一种面向实现的测试。测试代码通常与被测包的具体实现是紧耦合的。 包循环引用：很容易会带来包循环引用现象，而这是Go编译器不允许的 2.3. 包外测试 优势： 包外测试的本质是一种面向接口的黑盒测试。 这一本质让包外测试代码与被测试包充分解耦，使得针对这些导出API进行测试的包外测试代码表现出十分健壮的特性。 避免了包循环引用现象。 不足： 存在测试盲区：由于测试代码与被测试目标并不在同一包名下，测试代码仅有权访问被测包的导出符号，并且仅能通过导出API这一有限的“窗口”来验证被测包行为。 在这样的约束下，很容易出现对被测试包的测试覆盖不足的情况。 Go标准库的实现者们提供了一个解决这个问题的惯用法：安插后门。即使用export_test.go文件暴露被测包内部 2.4. 优先使用包外测试 包外测试由于将测试代码放入独立的包中，它更适合编写偏向集成测试的用例； 包内测试更聚焦于内部逻辑的测试，通过给函数/方法传入一些特意构造的数据的方式来验证内部逻辑的正确性； By YangXin Xu            updated 2023-10-07 23:14:39 "},"第41条-有层次地组织测试代码.html":{"url":"第41条-有层次地组织测试代码.html","title":"第41条-有层次地组织测试代码","keywords":"","body":"1. 经典模式——平铺2. xUnit家族模式3. 测试固件1. 经典模式——平铺 早期的测试代码采用了十分简单直接的组织方式——平铺。 下面是对Go1.5版本标准库strings包执行测试后的结果： $ go test -v . === RUN TestCompare --- PASS: TestCompare (0.00s) === RUN TestCompareIdenticalString --- PASS: TestCompareIdenticalString (0.00s) === RUN TestCompareStrings --- PASS: TestCompareStrings (0.00s) === RUN TestReader --- PASS: TestReader (0.00s) ... === RUN TestEqualFold --- PASS: TestEqualFold (0.00s) === RUN TestCount --- PASS: TestCount (0.00s) ... PASS ok strings 0.457s 这些测试函数各自独立，测试函数之间没有层级关系，所有测试平铺在顶层。 测试函数名称既用来区分测试，又用来关联测试。 2. xUnit家族模式 在Java、Python、C#等主流编程语言中，测试代码的组织形式深受由极限编程倡导者Kent Beck和Erich Gamma建立的xUnit家族测试框架（如JUnit、PyUnit等）的影响。 使用了xUnit家族单元测试框架的典型测试代码组织形式如下图所示： Go 1.7中加入的对subtest的支持让我们在Go中也可以使用上面这种方式组织Go测试代码： // chapter8/sources/strings-test-demo/compare_test.go package strings_test ... func testCompare(t *testing.T) { ... } func testCompareIdenticalString(t *testing.T) { ... } func testCompareStrings(t *testing.T) { ... } func TestCompare(t *testing.T) { t.Run(\"Compare\", testCompare) t.Run(\"CompareString\", testCompareStrings) t.Run(\"CompareIdenticalString\", testCompareIdenticalString) } // chapter8/sources/strings-test-demo/builder_test.go package strings_test ... func testBuilder(t *testing.T) { ... } func testBuilderString(t *testing.T) { ... } func testBuilderReset(t *testing.T) { ... } func testBuilderGrow(t *testing.T) { ... } func TestBuilder(t *testing.T) { t.Run(\"TestBuilder\", testBuilder) t.Run(\"TestBuilderString\", testBuilderString) t.Run(\"TestBuilderReset\", testBuilderReset) t.Run(\"TestBuilderGrow\", testBuilderGrow) } 运行一下改造后的测试： $go test -v . === RUN TestBuilder === RUN TestBuilder/TestBuilder === RUN TestBuilder/TestBuilderString === RUN TestBuilder/TestBuilderReset === RUN TestBuilder/TestBuilderGrow --- PASS: TestBuilder (0.00s) --- PASS: TestBuilder/TestBuilder (0.00s) --- PASS: TestBuilder/TestBuilderString (0.00s) --- PASS: TestBuilder/TestBuilderReset (0.00s) --- PASS: TestBuilder/TestBuilderGrow (0.00s) === RUN TestCompare === RUN TestCompare/Compare === RUN TestCompare/CompareString === RUN TestCompare/CompareIdenticalString --- PASS: TestCompare (0.44s) --- PASS: TestCompare/Compare (0.00s) --- PASS: TestCompare/CompareString (0.44s) --- PASS: TestCompare/CompareIdenticalString (0.00s) PASS ok strings-test-demo 0.446s 3. 测试固件 测试固件是指一个人造的、确定性的环境。一个测试用例或一个测试套件在这个环境中进行测试，其测试结果是可重复的。 下面是一些使用测试固件的常见场景： 将一组已知的特定数据加载到数据库中，测试结束后清除这些数据； 复制一组特定的已知文件，测试结束后清除这些文件； 创建伪对象（fake object）或模拟对象（mock object），并为这些对象设定测试时所需的特定数据和期望结果。 // chapter8/sources/classic_testfixture_test.go package demo_test ... func setUp(testName string) func() { fmt.Printf(\"\\tsetUp fixture for %s\\n\", testName) return func() { fmt.Printf(\"\\ttearDown fixture for %s\\n\", testName) } } func TestFunc1(t *testing.T) { defer setUp(t.Name())() fmt.Printf(\"\\tExecute test: %s\\n\", t.Name()) } func TestFunc2(t *testing.T) { defer setUp(t.Name())() fmt.Printf(\"\\tExecute test: %s\\n\", t.Name()) } func TestFunc3(t *testing.T) { defer setUp(t.Name())() fmt.Printf(\"\\tExecute test: %s\\n\", t.Name()) } $go test -v classic_testfixture_test.go === RUN TestFunc1 setUp fixture for TestFunc1 Execute test: TestFunc1 tearDown fixture for TestFunc1 --- PASS: TestFunc1 (0.00s) === RUN TestFunc2 setUp fixture for TestFunc2 Execute test: TestFunc2 tearDown fixture for TestFunc2 --- PASS: TestFunc2 (0.00s) === RUN TestFunc3 setUp fixture for TestFunc3 Execute test: TestFunc3 tearDown fixture for TestFunc3 --- PASS: TestFunc3 (0.00s) PASS ok command-line-arguments 0.005s 有时候我们需要将所有测试函数放入一个更大范围的测试固件环境中执行，这就是包级别测试固件。Go 1.4版本引入了TestMain，使得包级别测试固件的创建和销毁终于有了正式的施展舞台。 // chapter8/sources/classic_package_level_testfixture_test.go package demo_test ... func setUp(testName string) func() { fmt.Printf(\"\\tsetUp fixture for %s\\n\", testName) return func() { fmt.Printf(\"\\ttearDown fixture for %s\\n\", testName) } } func TestFunc1(t *testing.T) { t.Cleanup(setUp(t.Name())) fmt.Printf(\"\\tExecute test: %s\\n\", t.Name()) } func TestFunc2(t *testing.T) { t.Cleanup(setUp(t.Name())) fmt.Printf(\"\\tExecute test: %s\\n\", t.Name()) } func TestFunc3(t *testing.T) { t.Cleanup(setUp(t.Name())) fmt.Printf(\"\\tExecute test: %s\\n\", t.Name()) } func pkgSetUp(pkgName string) func() { fmt.Printf(\"package SetUp fixture for %s\\n\", pkgName) return func() { fmt.Printf(\"package TearDown fixture for %s\\n\", pkgName) } } func TestMain(m *testing.M) { defer pkgSetUp(\"package demo_test\")() m.Run() } $go test -v classic_package_level_testfixture_test.go package SetUp fixture for package demo_test === RUN TestFunc1 setUp fixture for TestFunc1 Execute test: TestFunc1 tearDown fixture for TestFunc1 --- PASS: TestFunc1 (0.00s) === RUN TestFunc2 setUp fixture for TestFunc2 Execute test: TestFunc2 tearDown fixture for TestFunc2 --- PASS: TestFunc2 (0.00s) === RUN TestFunc3 setUp fixture for TestFunc3 Execute test: TestFunc3 tearDown fixture for TestFunc3 --- PASS: TestFunc3 (0.00s) PASS package TearDown fixture for package demo_test ok command-line-arguments 0.008s 可以用下图来总结（带测试固件的）平铺模式下的测试执行流： 有些时候，一些测试函数所需的测试固件是相同的，在平铺模式下为每个测试函数都单独创建/销毁一次测试固件就显得有些重复和冗余。在这样的情况下，我们可以尝试采用测试套件来减少测试固件的重复创建： // chapter8/sources/xunit_suite_level_testfixture_test.go package demo_test ... func suiteSetUp(suiteName string) func() { fmt.Printf(\"\\tsetUp fixture for suite %s\\n\", suiteName) return func() { fmt.Printf(\"\\ttearDown fixture for suite %s\\n\", suiteName) } } func func1TestCase1(t *testing.T) { fmt.Printf(\"\\t\\tExecute test: %s\\n\", t.Name()) } func func1TestCase2(t *testing.T) { fmt.Printf(\"\\t\\tExecute test: %s\\n\", t.Name()) } func func1TestCase3(t *testing.T) { fmt.Printf(\"\\t\\tExecute test: %s\\n\", t.Name()) } func TestFunc1(t *testing.T) { t.Cleanup(suiteSetUp(t.Name())) t.Run(\"testcase1\", func1TestCase1) t.Run(\"testcase2\", func1TestCase2) t.Run(\"testcase3\", func1TestCase3) } func func2TestCase1(t *testing.T) { fmt.Printf(\"\\t\\tExecute test: %s\\n\", t.Name()) } func func2TestCase2(t *testing.T) { fmt.Printf(\"\\t\\tExecute test: %s\\n\", t.Name()) } func func2TestCase3(t *testing.T) { fmt.Printf(\"\\t\\tExecute test: %s\\n\", t.Name()) } func TestFunc2(t *testing.T) { t.Cleanup(suiteSetUp(t.Name())) t.Run(\"testcase1\", func2TestCase1) t.Run(\"testcase2\", func2TestCase2) t.Run(\"testcase3\", func2TestCase3) } func pkgSetUp(pkgName string) func() { fmt.Printf(\"package SetUp fixture for %s\\n\", pkgName) return func() { fmt.Printf(\"package TearDown fixture for %s\\n\", pkgName) } } func TestMain(m *testing.M) { defer pkgSetUp(\"package demo_test\")() m.Run() } $go test -v xunit_suite_level_testfixture_test.go package SetUp fixture for package demo_test === RUN TestFunc1 setUp fixture for suite TestFunc1 === RUN TestFunc1/testcase1 Execute test: TestFunc1/testcase1 === RUN TestFunc1/testcase2 Execute test: TestFunc1/testcase2 === RUN TestFunc1/testcase3 Execute test: TestFunc1/testcase3 tearDown fixture for suite TestFunc1 --- PASS: TestFunc1 (0.00s) --- PASS: TestFunc1/testcase1 (0.00s) --- PASS: TestFunc1/testcase2 (0.00s) --- PASS: TestFunc1/testcase3 (0.00s) === RUN TestFunc2 setUp fixture for suite TestFunc2 === RUN TestFunc2/testcase1 Execute test: TestFunc2/testcase1 === RUN TestFunc2/testcase2 Execute test: TestFunc2/testcase2 === RUN TestFunc2/testcase3 Execute test: TestFunc2/testcase3 tearDown fixture for suite TestFunc2 --- PASS: TestFunc2 (0.00s) --- PASS: TestFunc2/testcase1 (0.00s) --- PASS: TestFunc2/testcase2 (0.00s) --- PASS: TestFunc2/testcase3 (0.00s) PASS package TearDown fixture for package demo_test ok command-line-arguments 0.005s 在这样的测试代码组织方式下，我们仍然可以单独为每个测试用例创建和销毁测试固件，从而形成一种多层次的、更灵活的测试固件设置体系。可以用下图总结一下这种模式下的测试执行流： By YangXin Xu            updated 2023-10-07 14:06:32 "},"第42条-优先编写表驱动的测试.html":{"url":"第42条-优先编写表驱动的测试.html","title":"第42条-优先编写表驱动的测试","keywords":"","body":"1. Go测试代码的一般逻辑2. 表驱动的测试实践3. 表驱动测试的优点4. 表驱动测试实践中的注意事项4.1. 表的实现方式4.2. 测试失败时的数据项定位4.3. Errorf还是Fatalf1. Go测试代码的一般逻辑 对测试失败与否的判断在于测试代码逻辑是否进入了包含Error/Errorf、Fatal/Fatalf等方法调用的代码分支。 一旦进入这些分支，即代表该测试失败。 Error/Errorf并不会立刻终止当前goroutine的执行，还会继续执行该 goroutine后续的测试； 而Fatal/Fatalf则会立刻停止当前goroutine的测试执行； // chapter8/sources/non_table_driven_strings_test.go func TestCompare(t *testing.T) { var a, b string var i int a, b = \"\", \"\" i = 0 cmp := strings.Compare(a, b) if cmp != i { t.Errorf(`want %v, but Compare(%q, %q) = %v`, i, a, b, cmp) } a, b = \"a\", \"\" i = 1 cmp = strings.Compare(a, b) if cmp != i { t.Errorf(`want %v, but Compare(%q, %q) = %v`, i, a, b, cmp) } a, b = \"\", \"a\" i = -1 cmp = strings.Compare(a, b) if cmp != i { t.Errorf(`want %v, but Compare(%q, %q) = %v`, i, a, b, cmp) } } Go测试代码的一般逻辑：针对给定的输入数据，比较被测函数/方法返回的实际结果值与预期值，如有差异，则通过testing包提供的相关函数输出差异信息。 2. 表驱动的测试实践 上面的例子过于冗长，我么可以进行一些改进： // chapter8/sources/table_driven_strings_test.go func TestCompare(t *testing.T) { compareTests := []struct { a, b string i int }{ {\"\", \"\", 0}, {\"a\", \"\", 1}, {\"\", \"a\", -1}, } for _, tt := range compareTests { cmp := strings.Compare(tt.a, tt.b) if cmp != tt.i { t.Errorf(`want %v, but Compare(%q, %q) = %v`, tt.i, tt.a, tt.b, cmp) } } } 在这种测试设计中，这个自定义结构体类型的切片（上述示例中的compareTests）就是一个表（自定义结构体类型的字段就是列），而基于这个数据表的测试设计和实现则被称为“表驱动的测试”。 3. 表驱动测试的优点 表驱动测试本身是编程语言无关的。Go核心团队和Go早期开发者在实践过程中发现表驱动测试十分适合Go代码测试并在标准库和第三方项目中大量使用此种测试设计，这样表驱动测试也就逐渐成为Go的 一个惯用法。 简单和紧凑：这种简单和紧凑意味着测试代码更容易被开发者理解，因此在测试代码的生命周期内，基于表驱动的测试代码的可维护性更好。 数据即测试：表驱动测试的实质是数据驱动的测试，扩展输入数据集即扩展测试。 结合子测试后，可单独运行某个数据项的测试： 4. 表驱动测试实践中的注意事项 4.1. 表的实现方式 表可以使用基于自定义结构体的其他集合类型（如map）来实现： // chapter8/sources/table_driven_strings_with_map_test.go func TestCompare(t *testing.T) { compareTests := map[string]struct { a, b string i int }{ `compareTwoEmptyString`: {\"\", \"\", 0}, `compareSecondParamIsEmpty`: {\"a\", \"\", 1}, `compareFirstParamIsEmpty`: {\"\", \"a\", -1}, } for name, tt := range compareTests { t.Run(name, func(t *testing.T) { cmp := strings.Compare(tt.a, tt.b) if cmp != tt.i { t.Errorf(`want %v, but Compare(%q, %q) = %v`, tt.i, tt.a, tt.b, cmp) } }) } } // 第一次 $go test -v table_driven_strings_with_map_test.go === RUN TestCompare === RUN TestCompare/compareTwoEmptyString === RUN TestCompare/compareSecondParamIsEmpty === RUN TestCompare/compareFirstParamIsEmpty --- PASS: TestCompare (0.00s) --- PASS: TestCompare/compareTwoEmptyString (0.00s) --- PASS: TestCompare/compareSecondParamIsEmpty (0.00s) --- PASS: TestCompare/compareFirstParamIsEmpty (0.00s) PASS ok command-line-arguments 0.005s // 第二次 $go test -v table_driven_strings_with_map_test.go === RUN TestCompare === RUN TestCompare/compareFirstParamIsEmpty === RUN TestCompare/compareTwoEmptyString === RUN TestCompare/compareSecondParamIsEmpty --- PASS: TestCompare (0.00s) --- PASS: TestCompare/compareFirstParamIsEmpty (0.00s) --- PASS: TestCompare/compareTwoEmptyString (0.00s) --- PASS: TestCompare/compareSecondParamIsEmpty (0.00s) PASS ok command-line-arguments 0.005s 4.2. 测试失败时的数据项定位 对于表驱动的测试，我们无法通过失败点所在行数来定位出错的测试用例，于是我们需要 在测试失败时输出数据表项的唯一标识 通过输出数据表项在数据表中的偏移量来辅助定位“元凶” // chapter8/sources/table_driven_strings_by_offset_test.go func TestCompare(t *testing.T) { compareTests := []struct { a, b string i int }{ {\"\", \"\", 7}, {\"a\", \"\", 6}, {\"\", \"a\", -1}, } for i, tt := range compareTests { cmp := strings.Compare(tt.a, tt.b) if cmp != tt.i { t.Errorf(`[table offset: %v] want %v, but Compare(%q, %q) = %v`, i+1, tt.i, tt.a, tt.b, cmp) } } } 使用名字来区分不同的数据项 // chapter8/sources/table_driven_strings_by_name_test.go func TestCompare(t *testing.T) { compareTests := []struct { name, a, b string i int }{ {\"compareTwoEmptyString\", \"\", \"\", 7}, {\"compareSecondStringEmpty\", \"a\", \"\", 6}, {\"compareFirstStringEmpty\", \"\", \"a\", -1}, } for _, tt := range compareTests { cmp := strings.Compare(tt.a, tt.b) if cmp != tt.i { t.Errorf(`[%s] want %v, but Compare(%q, %q) = %v`, tt.name, tt.i, tt.a, tt.b, cmp) } } } 4.3. Errorf还是Fatalf 选择Errorf还是Fatalf并没有固定标准，一般而言: 如果一个数据项导致的测试失败不会对后续数据项的测试结果造成影响，那么推荐Errorf，这样可以通过执行一次测试看到所有导致测试失败的数据 项； 如果数据项导致的测试失败会直接影响到后续数据项的测试结果，那么可以使用Fatalf让测试尽快结束，因为继续执行的测试的意义已经不大了； By YangXin Xu            updated 2023-10-07 14:53:28 "},"第43条-使用testdata管理测试依赖的外部数据文件.html":{"url":"第43条-使用testdata管理测试依赖的外部数据文件.html","title":"第43条-使用testdata管理测试依赖的外部数据文件","keywords":"","body":"1. testdata目录2. golden文件惯用法 测试固件是Go测试执行所需的上下文环境，其中测试依赖的外部数据文件就是一种常见的测试固件（可以理解为静态测试固件，因为无须在测试代码中为其单独编写固件的创建和清理辅助函数）。 在本条中，我们就来看看Go管理测试依赖的外部数据文件所采用的一些惯例和最佳实践。 1. testdata目录 Go工具链将忽略名为testdata的目录。这样开发者在编写测试时，就可以在名为testdata的目录下存放和管理测试代码依赖的数据文件。 go test命令在执行时会将被测试程序包源码所在目录设置为其工作目录，我们可以直接在测试代码中像下面这样定位到充当测试固件的数据文件： f, err := os.Open(\"testdata/data-001.txt\") // 更具可移植性的代码 f, err := os.Open(filepath.Join(\"testdata\", \"data-001.txt\")) 2. golden文件惯用法 （略） By YangXin Xu            updated 2023-10-07 15:07:00 "},"第44条-正确使用fake、stub和mock等辅助单元测试.html":{"url":"第44条-正确使用fake、stub和mock等辅助单元测试.html","title":"第44条-正确使用fake、stub和mock等辅助单元测试","keywords":"","body":"1. fake：真实组件或服务的简化实现版替身2. stub：对返回结果有一定预设控制能力的替身3. mock：专用于行为观察和验证的替身在对Go代码进行测试的过程中，会经常面对被测代码对外部业务组件或服务的依赖。比如： 被测代码需要连接外部Redis服务； 被测代码依赖一个外部邮件服务器来发送电子邮件； 被测代码需与外部数据库建立连接并进行数据操作； 被测代码使用了某个外部RESTful服务； 在生产环境中为运行的业务代码提供其依赖的真实组件或服务是必不可少的，也是相对容易的。 但是在开发测试环境中，我们无法像在生产环境中那样，为测试（尤其是单元测试）提供真实运行的外部依赖。 为了能让对此类被测代码的测试进行下去，我们需要为这些被测代码提供其 依赖的外部组件或服务的替身： 显然用于代码测试的“替身”不必与真实组件或服务完全相同，替身只需要提供与真实组件或服务相同的接口，只要被测代码认为它是真实 的即可。 替身的概念是在测试驱动编程理论中被提出的。作为测试驱动编程理论的最佳实践，xUnit家族框架将替身的概念在单元测试中应用得淋漓尽致，并总结出多种替身，比如fake、stub、mock等。 1. fake：真实组件或服务的简化实现版替身 fake测试就是指采用真实组件或服务的简化版实现作为替身，以满足被测代码的外部依赖需求。 比如：当被测代码需要连接数据库进行相关操作时，虽然我们在开发测试环境中无法提供一个真实的关系数据库来满足测试需求，但是可以基于哈希表实现一个内存版数据库来满足测试代码要求，我们用这样一个伪数据库作为真实数据库的替身，使得测试顺利进行下去。 // $GOROOT/src/database/sql/fakedb_test.go ... type fakeDriver struct { mu sync.Mutex openCount int closeCount int waitCh chan struct{} waitingCh chan struct{} dbs map[string]*fakeDB } ... var fdriver driver.Driver = &fakeDriver{} func init() { Register(\"test\", fdriver) //将自己作为driver进行了注册 } ... // $GOROOT/src/database/sql/sql_test.go func TestUnsupportedOptions(t *testing.T) { db := newTestDB(t, \"people\") defer closeDB(t, db) _, err := db.BeginTx(context.Background(), &TxOptions{ Isolation: LevelSerializable, ReadOnly: true, }) if err == nil { t.Fatal(\"expected error when using unsupported options, got nil\") } } const fakeDBName = \"foo\" func newTestDB(t testing.TB, name string) *DB { return newTestDBConnector(t, &fakeConnector{name: fakeDBName}, name) } func newTestDBConnector(t testing.TB, fc *fakeConnector, name string) *DB { fc.name = fakeDBName db := OpenDB(fc) if _, err := db.Exec(\"WIPE\"); err != nil { t.Fatalf(\"exec wipe: %v\", err) } if name == \"people\" { exec(t, db, \"CREATE|people|name=string,age=int32,photo=blob,dead=bool,bdate=datetime\") exec(t, db, \"INSERT|people|name=Alice,age=?,photo=APHOTO\", 1) exec(t, db, \"INSERT|people|name=Bob,age=?,photo=BPHOTO\", 2) exec(t, db, \"INSERT|people|name=Chris,age=?,photo=CPHOTO,bdate=?\", 3, chrisBirthday) } if name == \"magicquery\" { exec(t, db, \"CREATE|magicquery|op=string,millis=int32\") exec(t, db, \"INSERT|magicquery|op=sleep,millis=10\") } return db } 使用fake替身进行测试的最常见理由是在测试环境无法构造被测代码所依赖的外部组件或服务，或者这些组件/服务有副作用。 fake替身的实现也有两个极端： 要么像标准库fakedb_test.go那样实现一个全功能的简化版内存数据库driver； 要么针对被测代码的调用请求仅返回硬编码的成功或失败； 这两种极端有一个共同点：并不具备在测试前对返回结果进行预设置的能力。 2. stub：对返回结果有一定预设控制能力的替身 和fake替身相比，stub替身增强了对替身返回结果的间接控制能力，这种控制可以通过测试前对调用结果预设置来实现。 不过，stub替身通常仅针对计划之内的结果进行设置，对计划之外的请求也无能为力。 在GitHub上有一个名为 gostub 的第三方包可以用于简化stub替身的管理和编写。 3. mock：专用于行为观察和验证的替身 和fake、stub替身相比，mock替身更为强大：它除了能提供测试前的预设置返回结果能力之外，还可以对mock替身对象在测试过程中的行为进行观察和验证。 和前两种替身相比，mock的应用范围要窄很多，只用于实现某接口的实现类型的替身。 一般需要通过第三方框架实现mock替身。Go官方维护了一个mock框架 —— gomock ，该框架通过代码生成的方式生成实现某接口的替身类型。 gomock是一个通用的mock框架，社区还有一些专用的mock框架可用于快速创建mock替身，比如：go-sqlmock专门用于创建sql/driver包中的Driver接口实现的mock替身，可以帮助Gopher简单、快速地建立起对数据库操作相关方法的单元测试。 By YangXin Xu            updated 2023-10-07 15:52:40 "},"第45条-使用模糊测试让潜在bug无处遁形.html":{"url":"第45条-使用模糊测试让潜在bug无处遁形.html","title":"第45条-使用模糊测试让潜在bug无处遁形","keywords":"","body":"1. 模糊测试在挖掘Go代码的潜在bug中的作用2. go-fuzz的初步工作原理3. go-fuzz使用方法3.1. 安装go-fuzz3.2. 带有模糊测试的项目组织3.3. go-fuzz-build3.4. 执行go-fuzz4. 使用go-fuzz建立模糊测试的示例5. 让模糊测试成为“一等公民”模糊测试：是指半自动或自动地为程序提供非法的、非预期、随机的数据，并监控程序在这些输入数据下是否会出现崩溃、内置断言失败、内存泄露、安全漏洞等情况。 在Go 1.5版本发布的同时，前英特尔黑带级工程师、现谷歌工程师Dmitry Vyukov发布了Go语言模糊测试工具go-fuzz。 传统软件测试一般会针对被测目标的特性进行人工测试设计。在设计一些异常测试用例的时候，测试用例质量好坏往往取决于测试设计人员对被测系统的理解程度及其个人能力。即便测试设计人员个人能力很强，对被测系统也有较深入的理解，他也很难在有限的时间内想到所有可能的异常组合和异常输入，尤其是面对庞大的分布式系统的时候。系统涉及的自身服务组件、中间件、第三方系统等多且复杂，这些系统中的潜在bug或者组合后形成的潜在bug是我们无法预知的。 而 将随机测试、边界测试、试探性攻击等测试技术集于一身的模糊测试 对于上述传统测试技术存在的问题是一个很好的补充和解决方案。 1. 模糊测试在挖掘Go代码的潜在bug中的作用 Dmitry Vyukov使用go-fuzz对当时（2015年）的Go标准库以及其他第三方开源库进行了模糊测试并取得了惊人的战果： // 60个测试 60 tests // 在Go标准库中发现137个bug(70个已经修复) 137 bugs in std lib (70 fixed) // 在其他项目中发现165个bug 165 elsewhere (47 in gccgo, 30 in golang.org/x, 42 in freetype-go, protobuf, http2, bson) go-fuzz的战绩在持续扩大，截至本书写作时，列在go-fuzz官方站点上的、由广大Gopher分享出来的已发现bug已有近400个，未分享出来的通过go-fuzz发现的bug估计远远不止这个数量。 2. go-fuzz的初步工作原理 go-fuzz的工作流程如下： 生成随机数据； 将上述数据作为输入传递给被测程序； 观察是否有崩溃记录（crash），如果发现崩溃记录，则说明找到了潜在的bug； go-fuzz采用的是 代码覆盖率引导的fuzzing算法（Coverage-guided fuzzing）。 go-fuzz运行起来后将进入一个死循环，该循环中的逻辑的伪代码大致如下： // go-fuzz-build在构建用于go-fuzz的二进制文件(*.zip)的过程中 // 在被测对象代码中埋入用于统计代码覆盖率的桩代码及其他信息 Instrument program for code coverage Collect initial corpus of inputs // 收集初始输入数据语料(位于工作路径下的corpus目录下) for { // 从corpus中读取语料并做随机变化 Randomly mutate an input from the corpus // 执行Fuzz，收集代码覆盖率数据 Execute and collect coverage // 如果输入数据提供了新的代码覆盖率，则将该输入数据存入语料库(corpus) If the input gives new coverage, add it to corpus } go-fuzz的核心是 对语料库的输入数据如何进行变化。go-fuzz内部使用两种对语料库的输入数据进行变化的方法：突变（mutation）和改写 （versify）： 突变：是一种低级方法，主要是对语料库的字节进行小修改。 插入/删除/重复/复制随机范围的随机字节； 位翻转； 交换2字节； 将一个字节设置为随机值； 从一个byte/uint16/uint32/uint64中添加/减去； 将一个byte/uint16/uint32替换为另一个值； 将一个ASCII数字替换为另一个数字； 拼接另一个输入； 插入其他输入的一部分； 插入字符串/整数字面值； 替换为字符串/整数字面值； 改写：是比较先进的高级方法，它会学习文本的结构，对输入进行简单分析，识别出输入语料数据中各个部分的类型，比如数字、字母数字、列表、引用等，然后针对不同部分运用突变策略。 3. go-fuzz使用方法 3.1. 安装go-fuzz 使用go-fuzz需要安装两个重要工具：go-fuzz-build和go-fuzz。通过标准go get就可以安装它们： $ go get github.com/dvyukov/go-fuzz/go-fuzz $ go get github.com/dvyukov/go-fuzz/go-fuzz-build 3.2. 带有模糊测试的项目组织 假设我们要对foo包进行模糊测试，那么其项目组织如下： github.com/bigwhite/fuzzexamples/foo/fuzztest]$tree . ├── fuzz1 │ ├── corpus // 存放输入数据语料的目录，在go-fuzz执行之前，可以放入初始语料； │ ├── fuzz.go // 包含Fuzz函数的源码文件 │ └── gen // 包含手工生成初始语料的main.go代码 │ └── main.go ├── fuzz2 │ ├── corpus │ ├── fuzz.go │ └── gen │ └── main.go ... 而fuzz.go源文件模板如下： // +build gofuzz package foo func Fuzz(data []byte) int { ... } go-fuzz-build在构建用于go-fuzz命令输入的二进制文件时，会搜索带有“+build gofuzz”指示符的Go源文件以及其中的Fuzz函数。 3.3. go-fuzz-build go-fuzz-build会根据Fuzz函数构建一个用于go-fuzz执行的zip包 （PACKAGENAME-fuzz.zip），包里包含了用途不同的三个文件： cover.exe：被注入了代码测试覆盖率桩设施的二进制文件。 sonar.exe：被注入了sonar统计桩设施的二进制文件。 metadata：包含代码覆盖率统计、sonar的元数据以及一些整型、 字符串字面值。 不过作为使用者，我们不必过于关心它们，点到为止。 3.4. 执行go-fuzz 一旦生成了foo-fuzz.zip，我们就可以执行针对fuzz1的模糊测试。 $cd fuzz1 $go-fuzz -bin=./foo-fuzz.zip -workdir=./ 2019/12/08 17:51:48 workers: 4, corpus: 8 (1s ago), crashers: 0, restarts: 1/0, execs: 0 (0/sec), cover: 0, uptime: 3s 2019/12/08 17:51:51 workers: 4, corpus: 9 (2s ago), crashers: 0, restarts: 1/3851, execs: 11553 (1924/sec), cover: 143, uptime: 6s 2019/12/08 17:51:54 workers: 4, corpus: 9 (5s ago), crashers: 0, restarts: 1/3979, execs: 47756 (5305/sec), cover: 143, uptime: 9s ... 如果corpus目录中没有初始语料数据，那么go-fuzz也会自行生成相 关数据传递给Fuzz函数，并且采用遗传算法，不断基于corpus中的语料生成新的输入语料。 go-fuzz作者建议corpus初始时放入的语料越多越好，而且要有足够的多样性，这样基于这些初始语料施展遗传算法，效果才会更佳。 go-fuzz在执行过程中还会将一些新语料持久化成文件放在corpus中，以供下次模糊测试执行时使用。 go-fuzz执行时是一个无限循环，上面的测试需要手动停下来。 go-fuzz会在指定的workdir中创建另两个目录：crashers和suppressions。 crashers中存放的是代码崩溃时的相关信息。 suppressions目录中则保存着崩溃时的栈跟踪信息，方便开发人员快速定位bug。 4. 使用go-fuzz建立模糊测试的示例 （略） 5. 让模糊测试成为“一等公民” 目前Go尚未将模糊测试当成“一 等公民”对待，即还没有在Go工具链上原生支持模糊测试，模糊测试在Go中的应用还仅限于使用第三方的go-fuzz或谷歌开源的gofuzz。 当前的go-fuzz等工具的实现存在一些无法解决的问题，比如： go-fuzz模仿Go工具构建逻辑，一旦Go原生工具构建逻辑发生变化，就会导致go-fuzz-build不断损坏； go-fuzz-build无法处理cgo，很难实现； 目前的代码覆盖率工具（coverage）是通过在源码中插入桩代码实现的，这使其很难与其他构建系统（build system）集成； 基于从源码到源码的转换无法处理所有情况，并且转换功能有限，某些代码模式可能会处理不当或导致构建失败； 使用从源码到源码转换的方法产生的代码运行很慢。重用需求； 这些问题需要编译器层面的支持，也就是在编译器层面添加支持模糊测试的基础设施（比如代码覆盖率桩的插入）。 By YangXin Xu            updated 2023-10-07 18:56:10 "},"第46条-为被测对象建立性能基准.html":{"url":"第46条-为被测对象建立性能基准.html","title":"第46条-为被测对象建立性能基准","keywords":"","body":"1. 性能基准测试在Go语言中是“一等公民”2. 顺序执行和并行执行的性能基准测试2.1. 顺序执行的性能基准测试2.2. 并行执行的性能基准测试3. 使用性能基准比较工具3.1. benchcmp3.2. benchstat4. 排除额外干扰，让基准测试更精确 著名计算机科学家、《计算机程序设计艺术》的作者高德纳曾说过： “过早优化是万恶之源。” 但是Android界开源大牛Jake Wharton就曾提出过这样一个观点：“过早的引用‘过早优化是万恶之源’是一切龟速软件之源。” 是否优化、何时优化实质上是一个决策问题，但决策不能靠直觉， 要靠数据说话。借用上面名言中的句型：没有数据支撑的过早决策是万 恶之源。 可以通过为被测对象建立性能基准的方式去获得决策是否优化的支撑数据，同时可以根据这些性能基准数据判断出对代码所做的任何更改是否对代码性能有所影响。 1. 性能基准测试在Go语言中是“一等公民” 性能基准测试在Go语言中是和普通的单元测试一样被原生支持的，得到的是“一等公民”的待遇。 每个以 Benchmark前缀开头的函数都会被当作一个独立的性能基准测试： func BenchmarkXxx(b *testing.B) { //... } // chapter8/sources/benchmark_intro_test.go var sl = []string{ \"Rob Pike \", \"Robert Griesemer \", \"Ken Thompson \", } func concatStringByOperator(sl []string) string { var s string for _, v := range sl { s += v } return s } func concatStringBySprintf(sl []string) string { var s string for _, v := range sl { s = fmt.Sprintf(\"%s%s\", s, v) } return s } func concatStringByJoin(sl []string) string { return strings.Join(sl, \"\") } func BenchmarkConcatStringByOperator(b *testing.B) { for n := 0; n &lt; b.N; n++ { concatStringByOperator(sl) } } func BenchmarkConcatStringBySprintf(b *testing.B) { for n := 0; n &lt; b.N; n++ { concatStringBySprintf(sl) } } func BenchmarkConcatStringByJoin(b *testing.B) { for n := 0; n &lt; b.N; n++ { concatStringByJoin(sl) } } 一起运行这三个基准测试： $go test -bench . benchmark_intro_test.go goos: darwin goarch: amd64 BenchmarkConcatStringByOperator-8 12810092 88.5 ns/op BenchmarkConcatStringBySprintf-8 2777902 432 ns/op BenchmarkConcatStringByJoin-8 23994218 49.7 ns/op PASS ok command-line-arguments 4.117s 以 BenchmarkConcatStringByJoin为例，其第三列的值为49.1ns/op，该值表 示BenchmarkConcatStringByJoin这个基准测试中for循环的每次循环平均执行时间为49.1ns（op代表每次循环操作）。这里for循环调用的是 concatStringByJoin，即执行一次concatStringByJoin的平均时长为49.1ns。 性能基准测试还可以通过传入-benchmem命令行参数输出内存分配信息（与基准测试代码中显式调用b.ReportAllocs的效果是等价的）： $go test -bench=Join ./benchmark_intro_test.go -benchmem goos: darwin goarch: amd64 BenchmarkConcatStringByJoin-8 23004709 48.8 ns/op 48 B/op 1 allocs/op PASS ok command-line-arguments 1.183s 这里输出的内存分配信息告诉我们，每执行一次concatStringByJoin平均进行一次内存分配，每次平均分配48字节的数据。 2. 顺序执行和并行执行的性能基准测试 2.1. 顺序执行的性能基准测试 其代码写法如下： func BenchmarkXxx(b *testing.B) { // ... for i := 0; i &lt; b.N; i++ { // 被测对象的执行代码 } } 2.2. 并行执行的性能基准测试 并行执行的性能基准测试的代码写法如下： func BenchmarkXxx(b *testing.B) { // ... b.RunParallel(func(pb *testing.PB) { for pb.Next() { // 被测对象的执行代码 } } } 3. 使用性能基准比较工具 现在我们已经可以通过Go原生提供的性能基准测试为被测对象建立性能基准了。但被测代码更新前后的性能基准比较依然要靠人工计算和肉眼比对，十分不方便。为此，Go核心团队先后开发了两款性能基准比较工具： benchcmp benchstat 3.1. benchcmp （略） 3.2. benchstat （略） Go核心团队已经给benchcmp工具打上了“deprecation”标签，因此建议大家使用benchstat来进行性能基准数据的比较。 4. 排除额外干扰，让基准测试更精确 有些复杂的基准测试在真正执行For循环之前或者在每个循环中，除了执行真正的被测代码之外，可能还需要做一些测试准备工作， 比如建立基准测试所需的测试上下文等。如果不做特殊处理，这些测试 准备工作所消耗的时间也会被算入最终结果中，这就会导致最终基准测试的数据受到干扰而不够精确。 为此，testing.B中提供了多种灵活操控基准测试计时器的方法，通过这些方法可以排除掉额外干扰，让基准测试结果更能反映被测代码的真实性能。 // chapter8/sources/benchmark_with_expensive_context_setup_test.go var sl = []string{ \"Rob Pike \", \"Robert Griesemer \", \"Ken Thompson \", } func concatStringByJoin(sl []string) string { return strings.Join(sl, \"\") } func expensiveTestContextSetup() { time.Sleep(200 * time.Millisecond) } func BenchmarkStrcatWithTestContextSetup(b *testing.B) { expensiveTestContextSetup() for n := 0; n &lt; b.N; n++ { concatStringByJoin(sl) } } func BenchmarkStrcatWithTestContextSetupAndResetTimer(b *testing.B) { expensiveTestContextSetup() b.ResetTimer() for n := 0; n &lt; b.N; n++ { concatStringByJoin(sl) } } func BenchmarkStrcatWithTestContextSetupAndRestartTimer(b *testing.B) { b.StopTimer() expensiveTestContextSetup() b.StartTimer() for n := 0; n &lt; b.N; n++ { concatStringByJoin(sl) } } func BenchmarkStrcat(b *testing.B) { for n := 0; n &lt; b.N; n++ { concatStringByJoin(sl) } } $go test -bench . benchmark_with_expensive_context_setup_test.go goos: darwin goarch: amd64 BenchmarkStrcatWithTestContextSetup-8 16943037 65.9 ns/op BenchmarkStrcatWithTestContextSetupAndResetTimer-8 21700249 52.7 ns/op BenchmarkStrcatWithTestContextSetupAndRestartTimer-8 21628669 50.5 ns/op BenchmarkStrcat-8 22915291 50.7 ns/op PASS ok command-line-arguments 9.838s By YangXin Xu            updated 2023-10-07 21:23:30 "},"第47条-使用pprof对程序进行性能剖析.html":{"url":"第47条-使用pprof对程序进行性能剖析.html","title":"第47条-使用pprof对程序进行性能剖析","keywords":"","body":"1. pprof的工作原理1.1. 采样数据类型1.2. 性能数据采集的方式1.3. 性能数据的剖析2. 使用pprof进行性能剖析的实例 Go还内置了对代码进行性能剖析的工具：pprof。pprof源自Google Perf Tools工具套件，在Go发布早期就被集成到Go工具链中了，并且Go运行时原生支持输出满足pprof需要的性能采样数据。 1. pprof的工作原理 使用pprof对程序进行性能剖析的工作一般分为两个阶段：数据采集 和 数据剖析 ，如下图所示： 1.1. 采样数据类型 在数据采集阶段，Go运行时会定期对剖析阶段所需的不同类型数据进行采样记录。当前主要支持的采样数据类型有以下几种： CPU数据（cpu.prof）：一旦启用CPU数据采样，Go运行时会每隔一段短暂的时间（10ms）就中断一次，并记录当前所有goroutine的函数栈信息（存入 cpu.prof）。 堆内存分配数据（mem.prof）：它能帮助我们了解Go程序的当前和历史内存使用情况。堆内存分配的采样频率可配置，默认每1000次堆内存分配会做一 次采样（存入mem.prof）。 锁竞争数据（mutex.prof）：锁竞争采样数据记录了当前Go程序中互斥锁争用导致延迟的操作。该类型采样数据在默认情况下是不启用的，请参见 runtime.SetMutexProfileFraction或go test -bench . xxx_test.go -mutexprofile mutex.out启用它。 阻塞时间数据（block.prof）：该类型采样数据记录的是goroutine在某共享资源（一般是由同步原语保护）上的阻塞时间，包括从无缓冲channel收发数据、阻塞在一个已经被其他goroutine锁住的互斥锁、向一个满了的channel发送数据或从一个空的channel接收数据等。该类型采样数据在默认情况下也是不启用的，请参见runtime.SetBlockProfileRate或go test -bench . xxx_test.go - blockprofile block.out启用它。 采样不是免费的，因此一次采样尽量仅采集一种类型的数据，不要同时采样多种类型的数据，避免相互干扰采样结果。 1.2. 性能数据采集的方式 通过性能基准测试进行数据采集 为应用中的关键函数/方法建立起性能基准测试之后，我们便可以通过执行性能基准测试采集到整个测试执行过程中有关被测方法的各类性能数据。这种方式尤其适用于对应用中关键路径上关键函数/方法性能的剖析。 $go test -bench . xxx_test.go -cpuprofile=cpu.prof $go test -bench . xxx_test.go -memprofile=mem.prof $go test -bench . xxx_test.go -blockprofile=block.prof $go test -bench . xxx_test.go -mutexprofile=mutex.prof 独立程序的性能数据采集 可以通过标准库runtime/pprof和runtime包提供的低级API对独立程序进行性能数据采集。 但是这种独立程序的性能数据采集方式对业务代码侵入较多，还要自己编写一些采集逻辑：定义flag变量、创建输出文件、关闭输出文件等。每次采集都要停止程序才能获取结果。（当然可 以重新定义更复杂的控制采集时间窗口的逻辑，实现不停止程序也能获 取采集数据结果。） Go在net/http/pprof包中还提供了一种更为高级的针对独立程序的性能数据采集方式，这种方式尤其适合那些内置了HTTP服务的独立程序。 1.3. 性能数据的剖析 Go工具链通过pprof子命令提供了两种性能数据剖析方法：命令行交互式和Web图形化。命令行交互式的剖析方法更常用，也是基本的性能数据剖析方法；而基于Web图形化的剖析方法在剖析结果展示上更为直观。 命令行交互方式 Web图形化方式 2. 使用pprof进行性能剖析的实例 （略） By YangXin Xu            updated 2023-10-07 22:24:25 "},"第48条-使用expvar输出度量数据，辅助定位性能瓶颈点.html":{"url":"第48条-使用expvar输出度量数据，辅助定位性能瓶颈点.html","title":"第48条-使用expvar输出度量数据，辅助定位性能瓶颈点","keywords":"","body":"1. expvar包的工作原理2. 自定义应用通过expvar输出的度量数据3. 输出数据的展示我们有两种收集和采样数据的方法： 在微观层面：采用通过 运行性能基准测试收集和采样数据 的方法， 这种方法适用于定位 函数或方法 实现中存在性能瓶颈点的情形； 在宏观层面：采用独立程序收集和采样数据的方法。但这种方法很难快速捕捉到真正的瓶颈点，尤其是那些结构复杂、业务逻辑过多、并发较多的Go程序。 那我们该如何更高效地捕捉到应用的性能瓶颈点呢？ 内省数据：可以反映应用运行状态的数据。 相比于通过查询应用外部特征而获取的探针类数据（比如查看应用某端口是否有响应并返回正确的数据或状态码），内省数据可以传达更为丰富、更多的有关应用程序状态的上下文信息。这些上下文信息可以是应用对各类资源的占用信息，比如应用运行占用了多少内存空间，也可以是自定义的性能指标信息，比如单位时间处理的外部请求数量、应答延迟、队列积压量等。 Go是“自带电池”的编程语言，我们可以轻松地使用Go标准库提供的expvar包按统一接口、统一数据格式、一致的指标定义方法输出自定义的度量数据。 1. expvar包的工作原理 2. 自定义应用通过expvar输出的度量数据 3. 输出数据的展示 By YangXin Xu            updated 2023-10-07 22:36:58 "},"第49条-使用Delve调试Go代码.html":{"url":"第49条-使用Delve调试Go代码.html","title":"第49条-使用Delve调试Go代码","keywords":"","body":"1. Go调试工具的选择2. Delve调试基础、原理与架构2.1. 安装Delve2.2. 使用Delve调试Go代码示例2.3. Delve架构与原理3. 并发、Coredump文件与挂接进程调试3.1. Delve调试并发程序3.2. 使用Delve调试core dump文件3.3. 使用Delve挂接到正在运行的进程进行调试1. Go调试工具的选择 在Go官方的2019年Go开发者报告中，有关Go开发过程依赖的调试工具与技术的调查结果如下图所示： print辅助调试 ：更多用于代码可修改的本地环境，通过“在特定位置添加打印值→编译执行→根据输出结果调查思考”的调试循环来逐渐逼近“真相”。 专业调试器 ：具有同样的功能，只是调试循环略烦琐，但是它具有如下优点： 与IDE集成，通过图形化操作可大幅简化专业调试器的调试循环，提供更佳的体验； 事后调查（postmortem） 调试core dump文件； 在生产环境通过挂接（attach）应用进程，深入应用进程内部进行调试。 在Go发行版中，除了标准的Go编译器之外，还有一个名为 gccgo 的编译器。和标准Go编译器相比，gccgo具有如下特点： gccgo是GCC编译器的新前端； Go语言由 Go语言规范 定义和驱动演进，gccgo是另一个实现了该语言规范的编译器，但与标准Go编译器实现的侧重点有所不同； gccgo编译速度较慢，但具有更为强大的优化能力； gccgo复用了GCC后端，因此支持的处理器架构更多； gccgo的演进速度与标准Go编译器的速度并不一致，按照 最新官方文档，gcc8等价于go 1.10.1的实现，而gcc9等价于Go 1.12.2的实现。 通过gccgo编译而成的Go程序可以得到GCC成熟工具链集合的原生支持，包括使用强大的GDB进行调试。 虽然GDB调试器是可以调试通过标准Go编译器编译生成的Go程序的，但GDB对标准Go编译器输出的程序的支持是不完善的。 由于gccgo不是主流，也不是我们重点考虑的内容，因此我们这里考虑的是基于标准Go编译器编译的代码的调试。 Delve 是另一个Go语言调试器， 该调试器工程于2014年由Derek Parker创建。 Delve旨在为Go提供一个简单、功能齐全、易用使用和调用的调试工具。 它紧跟Go语言版本演进，是目前Go调试器的事实标准。 和GDB相比，Delve可以更好地理解Go，对并发程序有着很好的支持，支持跨平台。 前后端分离的设计使得它可以非常容易地被集成到各种IDE、编译器插件、图形化调试器前端中。 2. Delve调试基础、原理与架构 2.1. 安装Delve $go get github.com/go-delve/delve/cmd/dlv $dlv version Delve Debugger Version: 1.4.1 Build: $Id: bda606147ff48b58bde39e20b9e11378eaa4db46 安装成功后，可执行文件dlv将出现在$GOPATH/bin下 2.2. 使用Delve调试Go代码示例 $tree . . ├── cmd │ └── delve-demo1 │ └── main.go ├── go.mod └── pkg └── foo └── foo.go 在delve-demo1目录下可以通过dlv debug命令来直接调试delve-demo1的main包： $cd delve-demo1 $dlv debug github.com/bigwhite/delve-demo1/cmd/delve-demo1 Type 'help' for list of commands. (dlv) 接下来就是使用相关命令来进行类gdb调试了，不再赘述（略） 2.3. Delve架构与原理 为了便于各种调试器前端（命令行、IDE、编辑器插件、图形化前端）与Delve集成，Delve采用了如下所示的前后分离的架构： UI Layer：对应的就是我们使用的dlv命令行或Goland/vim- go中的调试器前端。 Service Layer：用于前后端通信。 Symbolic Layer：真正了解被调试目标源码文件，通过读取Go编译器以DWARF格式写入目标二进制文件中的调试符号信息来了解被调试目标源码，并实现了被调试目标进程中的地址、二进制文件中的调试符号及源码相关信息三者之间的关系映射： Target Layer：通过各个操作系统提供的系统API来控制被调试目标进程，它对被调试目标的源码没有任何了解，实现的功能包括： 挂接/分离目标进程； 枚举目标进程中的线程； 启动/停止单个线程（或整个进程）； 接收和处理“调试事件”（线程创建/退出以及线程在断点处暂停）； 读写目标进程的内存； 读写停止线程的CPU寄存器； 读取core dump文件； 3. 并发、Coredump文件与挂接进程调试 3.1. Delve调试并发程序 Delve对并发Go程序则有着良好的支持，通过Delve提供调试命令，我们可以在各个运行的goroutine间切换。 例子：（略） 3.2. 使用Delve调试core dump文件 core dump文件：是在程序异常终止或崩溃时操作系统对程序当时的内存状态进行记录并保存而生成的一个数据文件，该文件以core命名，也被称为核心转储文件。 通过对操作系统记录的core文件中的数据的分析诊断，开发人员可以快速定位程序中存在的bug，这尤其适用于生产环境中的调试。 Delve目前支持对 linux/amd64、linux/arm64架构下产生的core文件的调试，以及 Windows/amd64架构下产生的minidump小转储文件的调试。 例子：（略） 3.3. 使用Delve挂接到正在运行的进程进行调试 在一些特定的情况下，我们可能需要对正在运行的Go应用进程进行调试。不过这类调试是有较大风险的：调试器一旦成功挂接到正在运 行的进程中，调试器就掌握了进程执行的指挥权，并且正在运行的goroutine都会暂停，等待调试器的进一步指令。 例子：（略） By YangXin Xu            updated 2023-10-08 16:13:18 "}}